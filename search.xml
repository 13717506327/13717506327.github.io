<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解构赋值]]></title>
    <url>%2F2018%2F07%2F22%2F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 数组的解构赋值1let [a, b, c] = [1, 2, 3]; 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // [] 如果解构不成功，变量的值就等于 undefined。 数组的不完全解构即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 指定默认值解构赋值允许指定默认值。12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 对象的解构赋值]]></content>
      <categories>
        <category>js原生</category>
        <category>ES6</category>
        <category>解构赋值</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>ES6</tag>
        <tag>解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Symbol]]></title>
    <url>%2F2018%2F07%2F22%2FSymbol%2F</url>
    <content type="text"><![CDATA[ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）;凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 用法：12let s = Symbol();typeof s // "symbol" 注意，Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。 Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。1234567let s1 = Symbol('foo');let s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // "Symbol(foo)"s2.toString() // "Symbol(bar)" 如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。123456789Symbol(&#123;&#125;) // Symbol([object Object])const obj = &#123; toString() &#123; return 'abc'; &#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc) 注意，Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。 Symbol 值不能与其他类型的值进行运算，会报错。123456let sym = Symbol('My symbol');"your symbol is " + sym// TypeError: can't convert symbol to string`your symbol is $&#123;sym&#125;`// TypeError: can't convert symbol to string 但是，Symbol 值可以显式转为字符串。1234let sym = Symbol('My symbol');String(sym) // 'Symbol(My symbol)'sym.toString() // 'Symbol(My symbol)' 作为属性名的 Symbol1234567891011121314151617let mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法let a = &#123; [mySymbol]: 'Hello!'&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;);// 以上写法都得到同样结果a[mySymbol] // "Hello!" 注意，Symbol 值作为对象属性名时，不能用点运算符。 Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。123456789const log = &#123;&#125;;log.levels = &#123; DEBUG: Symbol('debug'), INFO: Symbol('info'), WARN: Symbol('warn')&#125;;console.log(log.levels.DEBUG, 'debug message');console.log(log.levels.INFO, 'info message'); 属性名的遍历Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。 另一个新的 API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。1234567891011121314151617181920212223242526let size = Symbol('size');class Collection &#123; constructor() &#123; this[size] = 0; &#125; add(item) &#123; this[this[size]] = item; this[size]++; &#125; static sizeOf(instance) &#123; return instance[size]; &#125;&#125;let x = new Collection();Collection.sizeOf(x) // 0x.add('foo');Collection.sizeOf(x) // 1Object.keys(x) // ['0']Object.getOwnPropertyNames(x) // ['0']Object.getOwnPropertySymbols(x) // [Symbol(size)]]]></content>
      <categories>
        <category>js原生</category>
        <category>ES6</category>
        <category>Symbol</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>ES6</tag>
        <tag>Symbol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css布局技巧]]></title>
    <url>%2F2018%2F07%2F21%2Fcss%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[清除浮动12345678910.clearfix:after&#123; content: "020"; display: block; height: 0; clear: both; visibility: hidden; &#125;.clearfix &#123; zoom: 1; &#125;]]></content>
      <categories>
        <category>css</category>
        <category>布局技巧</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class]]></title>
    <url>%2F2018%2F07%2F20%2FClass%2F</url>
    <content type="text"><![CDATA[ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。 1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数Point，对应 ES6 的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6 的类，完全可以看作构造函数的另一种写法。 123456class Point &#123; // ...&#125;typeof Point // "function"Point === Point.prototype.constructor // true ES6 的类，完全可以看作构造函数的另一种写法。 123456class Point &#123; // ...&#125;typeof Point // "function"Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 12345678class Bar &#123; doStuff() &#123; console.log('stuff'); &#125;&#125;var b = new Bar();b.doStuff() // "stuff" 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。123456789101112131415161718192021class Point &#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。12345678910class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;); constructor方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。1234567class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; constructor 方法默认返回实例对象（即 this ），完全可以指定返回另外一个对象。12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。 类的实例对象生成类的实例对象的写法，与 ES5 完全一样，也是使用 new 命令。前面说过，如果忘记加上 new，像函数那样调用Class，将会报错。 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在 this 对象上），否则都是定义在原型上（即定义在 class 上）。12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与 ES5 的行为保持一致。 与 ES5 一样，类的所有实例共享一个原型对象。12345var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__//true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。 __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。 12345678910var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return 'Oops' &#125;;p1.printName() // "Oops"p2.printName() // "Oops"var p3 = new Point(4,2);p3.printName() // "Oops" 使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。 Class表达式与函数一样，类也可以使用表达式的形式定义。12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。1const MyClass = class &#123; /* ... */ &#125;; 不存在变量提升类不存在变量提升（hoist），这一点与 ES5 完全不同。 私有方法和私有属性私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 一种是在命名上加以区别1234567891011121314class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125; 这种命名是不保险的，在类的外部，还是可以调用到这个方法。1234567891011class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125; 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。1234567891011121314151617const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ...&#125;; Class 的 Generator方法如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。12345678910111213141516class Foo &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new Foo('hello', 'world')) &#123; console.log(x);&#125;// hello// world 上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。 class的 静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。 父类的静态方法，可以被子类继承。12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // 'hello' 静态方法也是可以从super对象上调用的。12345678910111213class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod() // "hello, too" 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。123456789101112131415class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1// 以下两种写法都无效class Foo &#123; // 写法一 prop: 2 // 写法二 static prop: 2&#125;Foo.prop // undefined new.target 属性new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。12345678910111213141516171819function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用 new 命令生成实例'); &#125;&#125;// 另一种写法function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用 new 命令生成实例'); &#125;&#125;var person = new Person('张三'); // 正确var notAPerson = Person.call(person, '张三'); // 报错 Class的继承Class 可以通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。12345class Point &#123;&#125;class ColorPoint extends Point &#123;&#125; 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。12345678class Point &#123; /* ... */ &#125;class ColorPoint extends Point &#123; constructor() &#123; &#125;&#125;let cp = new ColorPoint(); // ReferenceError 只有调用super之后，才可以使用this关键字，否则会报错。 super 关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。123456789101112131415161718192021222324class Parent &#123; static myMethod(msg) &#123; console.log('static', msg); &#125; myMethod(msg) &#123; console.log('instance', msg); &#125;&#125;class Child extends Parent &#123; static myMethod(msg) &#123; super.myMethod(msg); &#125; myMethod(msg) &#123; super.myMethod(msg); &#125;&#125;Child.myMethod(1); // static 1var child = new Child();child.myMethod(2); // instance 2 prototype 和 proto大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 子类的proto属性，表示构造函数的继承，总是指向父类。 子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。123456789101112131415161718192021class A &#123;&#125;class B &#123;&#125;// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A);const b = new B();Object.setPrototypeOf(B.prototype, A.prototype);// 等同于B.prototype.__proto__ = A.prototype;Object.setPrototypeOf(B, A);// 等同于B.__proto__ = A;]]></content>
      <categories>
        <category>js原生</category>
        <category>面向对象编程</category>
        <category>Class</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>面向对象编程</tag>
        <tag>Class</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex 布局]]></title>
    <url>%2F2018%2F07%2F20%2Fflex-%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。任何一个容器都可以指定为 Flex 布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性以下6个属性设置在容器上： flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap (默认)：不换行 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-contentjustify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self orderorder 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrinkflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basisflex 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125;]]></content>
      <categories>
        <category>css</category>
        <category>flex</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>flex</tag>
        <tag>弹性布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket]]></title>
    <url>%2F2018%2F07%2F20%2FWebSocket%2F</url>
    <content type="text"><![CDATA[它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。特点 建立在 TCP 协议之上，服务器端的实现比较容易。 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 数据格式比较轻量，性能开销小，通信高效。 可以发送文本，也可以发送二进制数据。 没有同源限制，客户端可以与任意服务器通信。 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。url格式1ws://example.com:80/some/path 客户端实例123456789101112131415var ws = new WebSocket("wss://echo.websocket.org");ws.onopen = function(evt) &#123; console.log("Connection open ..."); ws.send("Hello WebSockets!");&#125;;ws.onmessage = function(evt) &#123; console.log( "Received Message: " + evt.data); ws.close();&#125;;ws.onclose = function(evt) &#123; console.log("Connection closed.");&#125;; 客户端APIWebSocket 构造函数WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。1var ws = new WebSocket('ws://localhost:8080'); 执行上面语句之后，客户端就会与服务器进行连接。 webSocket.readyStatereadyState 属性返回实例对象的当前状态，共有四种。 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 1234567891011121314151617switch (ws.readyState) &#123; case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break;&#125; webSocket.onopen实例对象的onopen属性，用于指定连接成功后的回调函数。123ws.onopen = function () &#123; ws.send('Hello Server!');&#125; 如果要指定多个回调函数，可以使用addEventListener方法。123ws.addEventListener('open', function (event) &#123; ws.send('Hello Server!');&#125;); webSocket.onclose实例对象的onclose属性，用于指定连接关闭后的回调函数。12345678910111213ws.onclose = function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;;ws.addEventListener("close", function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;); webSocket.onmessage实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。123456789ws.onmessage = function(event) &#123; var data = event.data; // 处理数据&#125;;ws.addEventListener("message", function(event) &#123; var data = event.data; // 处理数据&#125;); webSocket.send()实例对象的send()方法用于向服务器发送数据。1ws.send('your message'); webSocket.onerror1234567socket.onerror = function(event) &#123; // handle error event&#125;;socket.addEventListener("error", function(event) &#123; // handle error event&#125;);]]></content>
      <tags>
        <tag>js原生</tag>
        <tag>node</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Module]]></title>
    <url>%2F2018%2F07%2F20%2FModule%2F</url>
    <content type="text"><![CDATA[ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 12345678// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 严格模式ES6 的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;;。 export 模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 export的写法: 写法一 1234// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958; 写法二 123456// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。12345678function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。123456789101112131415// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 导出 functionexport function f() &#123;&#125;;// 或者function f() &#123;&#125;export &#123;f&#125;;// 写法三var n = 1;export &#123;n as m&#125;; import 命令123456// main.js import &#123;firstName, lastName, year&#125; from './profile.js'; function setName(element) &#123; element.textContent = firstName + ' ' + lastName; &#125; 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。1import &#123; lastName as surname &#125; from './profile.js'; 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 下面是一个circle.js文件，它输出两个方法area和circumference。1234567891011121314// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125;import * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14)); export default 命令如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样。1import _, &#123; each, each as forEach &#125; from 'lodash';]]></content>
      <tags>
        <tag>js原生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async]]></title>
    <url>%2F2018%2F07%2F19%2Fasync%2F</url>
    <content type="text"><![CDATA[含义async 函数是什么？一句话，它就是 Generator 函数的语法糖。前文有一个 Generator 函数，依次读取两个文件。1234567891011121314151617const fs = require('fs');const readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;const gen = function* () &#123; const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 写成 async 函数，就是下面这样。123456const asyncReadFile = async function () &#123; const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; async 函数对 Generator 函数的改进，体现在以下四点。 内置执行器Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 1asyncReadFile(); 更好的语义。async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 更广的适用性co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 返回值是 Promiseasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。 基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); 下面是另一个例子，指定多少毫秒后输出一个值。123456789101112function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); 由于async函数返回的是 Promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式。123456789101112async function timeout(ms) &#123; await new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); async 函数有多种使用形式。123456789101112131415161718192021222324252627// 函数声明async function foo() &#123;&#125;// 函数表达式const foo = async function () &#123;&#125;;// 对象的方法let obj = &#123; async foo() &#123;&#125; &#125;;obj.foo().then(...)// Class 的方法class Storage &#123; constructor() &#123; this.cachePromise = caches.open('avatars'); &#125; async getAvatar(name) &#123; const cache = await this.cachePromise; return cache.match(`/avatars/$&#123;name&#125;.jpg`); &#125;&#125;const storage = new Storage();storage.getAvatar('jake').then(…);// 箭头函数const foo = async () =&gt; &#123;&#125;; async 语法** 返回 Promise 对象async函数返回一个 Promise 对象。async函数内部return语句返回的值，会成为then方法回调函数的参数。123456async function f() &#123; return 'hello world';&#125;f().then(v =&gt; console.log(v))// "hello world" async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。123456789async function f() &#123; throw new Error('出错了');&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e))// Error: 出错了 ** Promise 对象的状态改变1234567async function getTitle(url) &#123; let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];&#125;getTitle('https://tc39.github.io/ecma262/').then(console.log)// "ECMAScript 2017 Language Specification" 下面是一个例子。1234567async function getTitle(url) &#123; let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];&#125;getTitle('https://tc39.github.io/ecma262/').then(console.log)// "ECMAScript 2017 Language Specification" 上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。 ** await 命令正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。123456async function f() &#123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123 上面代码中，await命令的参数是数值123，它被转成 Promise 对象，并立即resolve。 await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。12345678async function f() &#123; await Promise.reject('出错了');&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// 出错了 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。1234async function f() &#123; await Promise.reject('出错了'); await Promise.resolve('hello world'); // 不会执行&#125; 有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。1234567891011async function f() &#123; try &#123; await Promise.reject('出错了'); &#125; catch(e) &#123; &#125; return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// hello world 另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。12345678910async function f() &#123; await Promise.reject('出错了') .catch(e =&gt; console.log(e)); return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// 出错了// hello world 错误处理如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。12345678910async function f() &#123; await new Promise(function (resolve, reject) &#123; throw new Error('出错了'); &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// Error：出错了 如果有多个await命令，可以统一放在try...catch结构中。123456789101112async function main() &#123; try &#123; const val1 = await firstStep(); const val2 = await secondStep(val1); const val3 = await thirdStep(val1, val2); console.log('Final: ', val3); &#125; catch (err) &#123; console.error(err); &#125;&#125; 使用注意点第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。12345678910111213141516async function myFunction() &#123; try &#123; await somethingThatReturnsAPromise(); &#125; catch (err) &#123; console.log(err); &#125;&#125;// 另一种写法async function myFunction() &#123; await somethingThatReturnsAPromise() .catch(function (err) &#123; console.log(err); &#125;);&#125; 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。]]></content>
      <categories>
        <category>js原生</category>
        <category>异步编程</category>
        <category>async</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>ES2017</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator]]></title>
    <url>%2F2018%2F07%2F19%2FGenerator%2F</url>
    <content type="text"><![CDATA[Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 Generator函数有两个特征 function关键字与函数名之间有一个*. 函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。123456789101112131415161718function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator();hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 yield 表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined。123function* gen() &#123; yield 123 + 456;&#125; 上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。 yield表达式如果用在另一个表达式之中，必须放在圆括号里面。 next 方法的参数yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。123456789101112function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。 再看一个通过next方法的参数，向 Generator 函数内部输入值的例子。1234567891011121314function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return 'result';&#125;let genObj = dataConsumer();genObj.next();// StartedgenObj.next('a')// 1. agenObj.next('b')// 2. b for…of 循环for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。123456789101112function* foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125; 上面代码使用for...of循环，依次显示 5 个yield表达式的值。这里需要注意，一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中。 下面是一个利用 Generator 函数和for...of循环，实现斐波那契数列的例子。123456789101112function* fibonacci() &#123; let [prev, curr] = [0, 1]; for (;;) &#123; yield curr; [prev, curr] = [curr, prev + curr]; &#125;&#125;for (let n of fibonacci()) &#123; if (n &gt; 1000) break; console.log(n);&#125; 从上面代码可见，使用for...of语句时不需要使用next方法。利用for...of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。123456789101112131415function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;for (let [key, value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 上面代码中，对象jane原生不具备 Iterator 接口，无法用for...of遍历。这时，我们通过 Generator 函数objectEntries为它加上遍历器接口，就可以用for...of遍历了。加上遍历器接口的另一种写法是，将 Generator 函数加到对象的Symbol.iterator属性上面。1234567891011121314151617function* objectEntries() &#123; let propKeys = Object.keys(this); for (let propKey of propKeys) &#123; yield [propKey, this[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of jane) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。123456789101112131415161718192021222324function* numbers () &#123; yield 1 yield 2 return 3 yield 4&#125;// 扩展运算符[...numbers()] // [1, 2]// Array.from 方法Array.from(numbers()) // [1, 2]// 解构赋值let [x, y] = numbers();x // 1y // 2// for...of 循环for (let n of numbers()) &#123; console.log(n)&#125;// 1// 2 Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。12345678910111213141516171819var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b'); // 不会被捕获&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 内部捕获 a// 外部捕获 b throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。如果 Generator 函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获。 如果 Generator 函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行。 throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。1234567891011121314var gen = function* gen()&#123; try &#123; yield console.log('a'); &#125; catch (e) &#123; // ... &#125; yield console.log('b'); yield console.log('c');&#125;var g = gen();g.next() // ag.throw() // bg.next() // c 上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要 Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。 Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的catch捕获。 Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: "foo", done: true &#125;g.next() // &#123; value: undefined, done: true &#125; yield* 表达式如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。 12345678910111213141516function* foo() &#123; yield 'a'; yield 'b';&#125;function* bar() &#123; yield 'x'; foo(); yield 'y';&#125;for (let v of bar())&#123; console.log(v);&#125;// "x"// "y" 这个就需要用到yield*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。123456789101112131415161718192021222324252627282930function* bar() &#123; yield 'x'; yield* foo(); yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; yield 'a'; yield 'b'; yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; for (let v of foo()) &#123; yield v; &#125; yield 'y';&#125;for (let v of bar())&#123; console.log(v);&#125;// "x"// "a"// "b"// "y" 有return语句时，则需要用var value = yield* iterator的形式获取return语句的值。1234567891011121314151617181920212223242526function* foo() &#123; yield 2; yield 3; return "foo";&#125;function* bar() &#123; yield 1; var v = yield* foo(); console.log("v: " + v); yield 4;&#125;var it = bar();it.next()// &#123;value: 1, done: false&#125;it.next()// &#123;value: 2, done: false&#125;it.next()// &#123;value: 3, done: false&#125;it.next();// "v: foo"// &#123;value: 4, done: false&#125;it.next()// &#123;value: undefined, done: true&#125; yield*命令可以很方便地取出嵌套数组的所有成员。1234567891011121314151617181920function* iterTree(tree) &#123; if (Array.isArray(tree)) &#123; for(let i=0; i &lt; tree.length; i++) &#123; yield* iterTree(tree[i]); &#125; &#125; else &#123; yield tree; &#125;&#125;const tree = [ 'a', ['b', 'c'], ['d', 'e'] ];for(let x of iterTree(tree)) &#123; console.log(x);&#125;// a// b// c// d// e 应用Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。 异步操作的同步化表达1234567891011function* loadUI() &#123; showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen();&#125;var loader = loadUI();// 加载UIloader.next()// 卸载UIloader.next() 上面代码中，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示Loading界面（showLoadingScreen），并且异步加载数据（loadUIDataAsynchronously）。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。 Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。1234567891011121314function* main() &#123; var result = yield request("http://some.url"); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;);&#125;var it = main();it.next(); 控制流管理1234567891011function* longRunningTask(value1) &#123; try &#123; var value2 = yield step1(value1); var value3 = yield step2(value2); var value4 = yield step3(value3); var value5 = yield step4(value4); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125; 然后，使用一个函数，按次序自动执行所有步骤。12345678910scheduler(longRunningTask(initialValue));function scheduler(task) &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125;&#125;]]></content>
      <categories>
        <category>js原生</category>
        <category>异步编程</category>
        <category>Generator</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>异步编程</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise]]></title>
    <url>%2F2018%2F07%2F18%2FPromise%2F</url>
    <content type="text"><![CDATA[Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。 Promise 特点Promise对象有以下两个特点： Promise对象状态不受外界影响Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 后面的resolved统一只指fulfilled状态，不包含rejected状态。 基本用法下面代码创造了一个Promise实例。123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 下面是一个Promise对象的简单例子。12345678function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); Promise 新建后就会立即执行。1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// Promise// Hi!// resolved 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 下面是异步加载图片的例子。123456789101112131415function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 下面是一个用Promise对象实现的 Ajax 操作的例子。1234567891011121314151617181920212223242526272829const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); &#125;); return promise;&#125;;getJSON("/posts.json").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); 上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。12345678const p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);// 2// 1 上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345new Promise((resolve, reject) =&gt; &#123; return resolve(1); // 后面的语句不会执行 console.log(2);&#125;) Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 12345getJSON("/posts.json").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567getJSON("/post/1.json").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log("resolved: ", comments);&#125;, function funcB(err)&#123; console.log("rejected: ", err);&#125;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。 Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 1234567891011121314p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log("rejected:", err));const promise = new Promise(function(resolve, reject) &#123; throw new Error('test');&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// Error: test 上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。12345678910111213141516171819// 写法一const promise = new Promise(function(resolve, reject) &#123; try &#123; throw new Error('test'); &#125; catch(e) &#123; reject(e); &#125;&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// 写法二const promise = new Promise(function(resolve, reject) &#123; reject(new Error('test')); // reject方法的作用，等同于抛出错误。&#125;);promise.catch(function(error) &#123; console.log(error);&#125;); 注意：Promise 在resolve语句后面，再抛出错误，不会被捕获 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 1234567getJSON('/post/1.json').then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。12345678910111213141516const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().catch(function(error) &#123; console.log('oh no', error);&#125;).then(function() &#123; console.log('carry on');&#125;);// oh no [ReferenceError: x is not defined]// carry on Promise.prototype.finally()finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。1const p = Promise.all([p1, p2, p3]); 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。12345678910// 生成一个Promise对象的数组const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON('/post/' + id + ".json");&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); 上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。 Promise.race()Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。1const p = Promise.race([p1, p2, p3]); 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.resolve()有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。1const jsPromise = Promise.resolve($.ajax('/whatever.json')); 上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) 参数是一个 Promise 实例如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。参数是一个thenable对象12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); 上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。 参数不是具有then方法的对象，或根本就不是对象如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。123456const p = Promise.resolve('Hello');p.then(function (s)&#123; console.log(s)&#125;);// Hello 不带有任何参数Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。需要注意的是，立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。12345678910111213setTimeout(function () &#123; console.log('three');&#125;, 0);Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。]]></content>
      <categories>
        <category>js原生</category>
        <category>异步编程</category>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this 关键字]]></title>
    <url>%2F2018%2F07%2F18%2Fthis-%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[this就是属性或方法“当前”所在的对象。12345678910111213141516171819202122var person = &#123; name: '张三', describe: function () &#123; return '姓名：'+ this.name; &#125;&#125;;person.describe()// "姓名：张三"function f() &#123; return '姓名：'+ this.name;&#125;var A = &#123; name: '张三', describe: f&#125;;var B = &#123; name: '李四', describe: f&#125;;A.describe() // "姓名：张三"B.describe() // "姓名：李四" 再看一个网页编程的例子。12345678&lt;input type="text" name="age" size=3 onChange="validate(this, 18, 99);"&gt;&lt;script&gt; function validate(obj, lowval, hival)&#123; if ((obj.value &lt; lowval) || (obj.value &gt; hival)) console.log('Invalid Value!'); &#125;&lt;/script&gt; this的设计目的就是在函数体内部，指代函数当前的运行环境。 使用场景全局环境全局环境使用this，它指的就是顶层对象window。 构造函数构造函数中的this，指的是实例对象。 对象的方法如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。 独立函数或回调函数独立函数（未绑定到其他对象上）的this指向window回调函数中的 this 指向 不确定; 谁调用指向谁。如：数组的forEach方法的回调函数中的this，其实是指向window对象，可以将this当作forEach方法的第二个参数，固定它的运行环境 但是，下面这几种用法，都会改变this的指向。123456// 情况一(obj.foo = obj.foo)() // window// 情况二(false || obj.foo)() // window// 情况三(1, obj.foo)() // window 可以这样理解，JavaScript 引擎内部，obj和obj.foo储存在两个内存地址，称为地址一和地址二。obj.foo()这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，this指向obj。但是，上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此this指向全局环境。上面三种情况等同于下面的代码。1234567891011var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: 'Hello' &#125;&#125;;var hello = a.b.m; // 将最内层函数赋值给全局变量后 this 指向 全局hello() // undefined 严格模式下，如果函数内部的this指向顶层对象，就会报错。12345678910var counter = &#123; count: 0&#125;;counter.inc = function () &#123; 'use strict'; this.count++&#125;;var f = counter.inc;f()// TypeError: Cannot read property 'count' of undefined 绑定this 的方法this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。 Function.prototype.call()函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 1func.call(thisValue, arg1, arg2, ...) call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。 call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。 如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。 Function.prototype.apply()apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。1func.apply(thisValue, [arg1, arg2, ...]) 原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。 Function.prototype.bind()bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。12345678910var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var func = counter.inc.bind(counter);func();counter.count // 1 bind还可以接受更多的参数，将这些参数绑定原函数的参数。123456789var add = function (x, y) &#123; return x * this.m + y * this.n;&#125;var obj = &#123; m: 2, n: 2&#125;;var newAdd = add.bind(obj, 5);newAdd(5) // 20 bind方法有一些使用注意点。每一次返回一个新函数bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。1234element.addEventListener('click', o.m.bind(o));// click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定element.removeEventListener('click', o.m.bind(o)); 正确的方法是写成下面这样：1234var listener = o.m.bind(o);element.addEventListener('click', listener);// ...element.removeEventListener('click', listener); 结合回掉函数使用回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。解决方法就是使用bind方法，将counter.inc绑定counter。123456789101112var counter = &#123; count: 0, inc: function () &#123; 'use strict'; this.count++; &#125;&#125;;function callIt(callback) &#123; callback();&#125;callIt(counter.inc.bind(counter));counter.count // 1 上面代码中，callIt方法会调用回调函数。这时如果直接把counter.inc传入，调用时counter.inc内部的this就会指向全局对象。使用bind方法将counter.inc绑定counter以后，就不会有这个问题，this总是指向counter。还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。12345678910111213141516171819var obj = &#123; name: '张三', times: [1, 2, 3], print: function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;); &#125;&#125;;obj.print = function () &#123; this.times.forEach(function (n) &#123; console.log(this === window); &#125;);&#125;;obj.print()// true// true// true 解决这个问题，也是通过bind方法绑定this。12345678910obj.print = function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;.bind(this));&#125;;obj.print()// 张三// 张三// 张三]]></content>
      <categories>
        <category>js原生</category>
        <category>Object</category>
        <category>this</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>Object</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象编程]]></title>
    <url>%2F2018%2F07%2F18%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 构造函数JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。123var Vehicle = function () &#123; this.price = 1000;&#125;; 构造函数的特点有两个。 函数体内部使用了this关键字，代表了所要生成的对象实例。 生成对象的时候，必须使用new命令。 new 命令基本用法new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。 如果忘了使用new命令，直接调用构造函数, 构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。 为了保证构造函数必须与new命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上use strict。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。1234567function Fubar(foo, bar)&#123; 'use strict'; this._foo = foo; this._bar = bar;&#125;Fubar()// TypeError: Cannot set property '_foo' of undefined 另一个解决办法，构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。12345678910function Fubar(foo, bar) &#123; if (!(this instanceof Fubar)) &#123; return new Fubar(foo, bar); &#125; this._foo = foo; this._bar = bar;&#125;Fubar(1, 2)._foo // 1(new Fubar(1, 2))._foo // 1 new 命令的原理使用new命令时，它后面的函数依次执行下面的步骤。 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。如果构造函数内部有return语句，而且如果return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。 new.target函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。使用这个属性，可以判断函数调用的时候，是否使用new命令。12345678function f() &#123; if (!new.target) &#123; throw new Error('请使用 new 命令调用！'); &#125; // ...&#125;f() // Uncaught Error: 请使用 new 命令调用！ Object.create()构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。12345678910var person1 = &#123; name: '张三', age: 38, greeting: function() &#123; console.log('Hi! I\'m ' + this.name + '.'); &#125;&#125;;var person2 = Object.create(person1);person2.name // 张三person2.greeting() // Hi! I'm 张三. 对象的继承面向对象编程很重要的一个方面，就是对象的继承。A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的。 大部分面向对象的编程语言，都是通过“类”（class）来实现对象的继承。JavaScript 语言的继承则是通过“原型对象”（prototype）。 原型对象概述构造函数的缺点JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。 通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。1234567891011function Cat(name, color) &#123; this.name = name; this.color = color; this.meow = function () &#123; console.log('喵喵'); &#125;;&#125;var cat1 = new Cat('大毛', '白色');var cat2 = new Cat('二毛', '黑色');cat1.meow === cat2.meow// false 这就需要javaScript 的原型对象（prototype） prototype 属性的作用JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。 JavaScript 规定，每个函数都有一个prototype属性，指向一个对象。12345678function Animal(name) &#123; this.name = name;&#125;Animal.prototype.color = 'white';var cat1 = new Animal('大毛');var cat2 = new Animal('二毛');cat1.color // 'white'cat2.color // 'white' 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。12345cat1.color = 'black';cat1.color // 'black'cat2.color // 'yellow'Animal.prototype.color // 'yellow'; 原型链JavaScript 规定，所有对象都有自己的原型对象（_proto_）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型…… 如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性。也就是说，所有对象都继承了Object.prototype的属性。这就是所有对象都有valueOf和toString方法的原因，因为这是从Object.prototype继承的。 Object.prototype的原型是null。 constructorprototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。12function P() &#123;&#125;P.prototype.constructor === P // true 有了constructor属性，就可以从一个实例对象新建另一个实例。12345function Constr() &#123;&#125;var x = new Constr();var y = new x.constructor();y instanceof Co constructor属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改constructor属性。所以，修改原型对象时，一般要同时修改constructor属性的指向。 instanceof 运算符instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。12var v = new Vehicle();v instanceof Vehicle // true instanceof运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。123v instanceof Vehicle// 等同于Vehicle.prototype.isPrototypeOf(v) 有一种特殊情况，就是左边对象的原型链上，只有null对象。这时，instanceof判断会失真。123var obj = Object.create(null);typeof obj // "object"Object.create(null) instanceof Object // false 上面代码中，Object.create(null)返回一个新对象obj，它的原型是null（Object.create的详细介绍见后文）。右边的构造函数Object的prototype属性，不在左边的原型链上，因此instanceof就认为obj不是Object的实例。但是，只要一个对象的原型不是null，instanceof运算符的判断就不会失真。 构造函数的继承让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。12345function Sub(value) &#123; // Super 父类构造函数 Super.call(this); this.prop = value;&#125; 上面代码中，Sub是子类的构造函数，this是子类的实例。在实例上调用父类的构造函数Super，就会让子类实例具有父类实例的属性。第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。123Sub.prototype = Object.create(Super.prototype);Sub.prototype.constructor = Sub;Sub.prototype.method = '...'; 上面代码中，Sub.prototype是子类的原型，要将它赋值为Object.create(Super.prototype)，而不是直接等于Super.prototype。否则后面两行对Sub.prototype的操作，会连父类的原型Super.prototype一起修改掉。 另外一种写法是Sub.prototype等于一个父类实例。1Sub.prototype = new Super(); 上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。 只需要单个方法的继承，这时可以采用下面的写法。1234ClassB.prototype.print = function() &#123; ClassA.prototype.print.call(this); // some code&#125; 多重继承JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。123456789101112131415161718192021222324function M1() &#123; this.hello = 'hello';&#125;function M2() &#123; this.world = 'world';&#125;function S() &#123; M1.call(this); M2.call(this);&#125;// 继承 M1S.prototype = Object.create(M1.prototype);// 继承链上加入 M2Object.assign(S.prototype, M2.prototype);// 指定构造函数S.prototype.constructor = S;var s = new S();s.hello // 'hello：'s.world // 'world' 模块JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果。 基本的实现方法模块是实现特定功能的一组属性和方法的封装。123456789var module1 = new Object(&#123; _count : 0, m1 : function ()&#123; //... &#125;, m2 : function ()&#123; //... &#125;&#125;); 上面的函数m1和m2，都封装在module1对象里。使用的时候，就是调用这个对象的属性。但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。 封装私有变量：构造函数的写法我们可以利用构造函数，封装私有变量。1234567891011function StringBuilder() &#123; var buffer = []; this.add = function (str) &#123; buffer.push(str); &#125;; this.toString = function () &#123; return buffer.join(''); &#125;;&#125; 上面代码中，buffer是模块的私有变量。一旦生成实例对象，外部是无法直接访问buffer的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存。12345678910111213function StringBuilder() &#123; this._buffer = [];&#125;StringBuilder.prototype = &#123; constructor: StringBuilder, add: function (str) &#123; this._buffer.push(str); &#125;, toString: function () &#123; return this._buffer.join(''); &#125;&#125;; 这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。 封装私有变量：立即执行函数的写法另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。12345678910111213var module1 = (function () &#123; var _count = 0; var m1 = function () &#123; //... &#125;; var m2 = function () &#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;;&#125;)(); 使用上面的写法，外部代码无法读取内部的_count变量。上面的module1就是 JavaScript 模块的基本写法。下面，再对这种写法进行加工。 模块的放大模式如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）123456var module1 = (function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod;&#125;)(module1); 上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。 在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。1234var module1 = (function (mod) &#123; //... return mod;&#125;)(window.module1 || &#123;&#125;); 输入全局变量独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。 为了在模块内部调用全局变量，必须显式地将其他变量输入模块。123var module1 = (function ($, YAHOO) &#123; //...&#125;)(jQuery, YAHOO); 上面的module1模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。立即执行函数还可以起到命名空间的作用。 立即执行函数还可以起到命名空间的作用。123456789101112131415161718192021(function($, window, document) &#123; function go(num) &#123; &#125; function handleEvents() &#123; &#125; function initialize() &#123; &#125; function dieCarouselDie() &#123; &#125; //attach to the global scope window.finalCarousel = &#123; init : initialize, destroy : dieCouraselDie &#125;&#125;)( jQuery, window, document ); 上面代码中，finalCarousel对象输出到全局，对外暴露init和destroy接口，内部方法go、handleEvents、initialize、dieCarouselDie都是外部无法调用的。]]></content>
      <categories>
        <category>js原生</category>
        <category>面向对象编程</category>
        <category>Class</category>
        <category>继承</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>面向对象编程</tag>
        <tag>继承</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegExp]]></title>
    <url>%2F2018%2F07%2F17%2FRegExp%2F</url>
    <content type="text"><![CDATA[RegExp对象创建新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。1var regx = /xyz/; 另一种是使用RegExp构造函数；RegExp构造函数还可以接受第二个参数，表示修饰符1var regex = new RegExp('xyz'); 实例属性修饰符相关属性返回一个布尔值，表示对应的修饰符是否设置,三个属性都是只读的。 RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了 i 修饰符。 RegExp.prototype.global：返回一个布尔值，表示是否设置了 g 修饰符。 RegExp.prototype.multiline：返回一个布尔值，表示是否设置了 m 修饰符。 与修饰符无关的属性 RegExp.prototype.lastIndex：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义。 RegExp.prototype.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。1234var r = /abc/igm;r.lastIndex // 0r.source // "abc" 实例方法RegExp.prototype.test()正则实例对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。1/cat/.test('cats and dogs') // true 如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。123456789101112var r = /x/g;var s = '_x_x';r.lastIndex // 0r.test(s) // truer.lastIndex // 2r.test(s) // truer.lastIndex // 4// 字符串的第五个位置开始搜索，这个位置是没有字符的，所以返回false。r.test(s) // false 注意，带有g修饰符时，正则表达式内部会记住上一次的lastIndex属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误。123var r = /bb/g;r.test('bb') // truer.test('-bb-') // false RegExp.prototype.exec()正则实例对象的exec方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。123456var s = '_x_x';var r1 = /x/;var r2 = /y/;r1.exec(s) // ["x"]r2.exec(s) // null 如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。1234var s = '_x_x';var r = /_(x)/;r.exec(s) // ["_x", "x"] exec方法的返回数组还包含以下两个属性： input：整个原字符串。 index：整个模式匹配成功的开始位置（从0开始计数）。 12345var r = /a(b+)a/;var arr = r.exec('_abbba_aba_');arr // ["abbba", "bbb"]arr.index // 1arr.input // "_abbba_aba_" 如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。123456789101112131415161718192021var reg = /a/g;var str = 'abc_abc_abc'var r1 = reg.exec(str);r1 // ["a"]r1.index // 0reg.lastIndex // 1var r2 = reg.exec(str);r2 // ["a"]r2.index // 4reg.lastIndex // 5var r3 = reg.exec(str);r3 // ["a"]r3.index // 8reg.lastIndex // 9var r4 = reg.exec(str);r4 // nullreg.lastIndex // 0 利用g修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。1234567891011var reg = /a/g;var str = 'abc_abc_abc'while(true) &#123; var match = reg.exec(str); if (!match) break; console.log('#' + match.index + ':' + match[0]);&#125;// #0:a// #4:a// #8:a 字符串的实例方法字符串的实例方法之中，有4种与正则表达式有关。 String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。 String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。 String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。 String.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。 String.prototype.match()字符串实例对象的match方法对字符串进行正则匹配，返回匹配结果。123456var s = '_x_x';var r1 = /x/;var r2 = /y/;s.match(r1) // ["x"]s.match(r2) // null 从上面代码可以看到，字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。如果正则表达式带有 g 修饰符，则该方法与正则对象的 exec 方法行为不同，会一次性返回所有匹配成功的结果。12345var s = 'abba';var r = /a/g;// 会一次性返回所有匹配成功的结果。s.match(r) // ["a", "a"]r.exec(s) // ["a"] 设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。1234var r = /a|b/g;r.lastIndex = 7;'xaxb'.match(r) // ['a', 'b']r.lastIndex // 0 String.prototype.search()字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。12'_x_x'.search(/x/)// 1 String.prototype.replace()字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。1str.replace(search, replacement) 正则表达式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。123'aaa'.replace('a', 'b') // "baa"'aaa'.replace(/a/, 'b') // "baa"'aaa'.replace(/a/g, 'b') // "bbb" replace方法的一个应用，就是消除字符串首尾两端的空格。1234var str = ' #id div.class ';str.replace(/^\s+|\s+$/g, '')// "#id div.class" replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。 $&amp;：匹配的子字符串。 $`：匹配结果前面的文本。 $’：匹配结果后面的文本。 $n：匹配成功的第n组内容，n是从1开始的自然数。 $$: 指代美元符号$。12345678910'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1')// "world hello"'abc'.replace('b', '[$`-$&amp;-$\']')// "a[a-b-c]c"'3 and 5'.replace(/[0-9]+/g, function (match) &#123; return 2 * match;&#125;)// "6 and 10" 作为replace方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。1234567891011121314151617var prices = &#123; 'p1': '$1.99', 'p2': '$9.99', 'p3': '$5.00'&#125;;var template = '&lt;span id="p1"&gt;&lt;/span&gt;' + '&lt;span id="p2"&gt;&lt;/span&gt;' + '&lt;span id="p3"&gt;&lt;/span&gt;';template.replace( /(&lt;span id=")(.*?)("&gt;)(&lt;\/span&gt;)/g, function(match, $1, $2, $3, $4)&#123; return $1 + $2 + $3 + prices[$2] + $4; &#125;);// "&lt;span id="p1"&gt;$1.99&lt;/span&gt;&lt;span id="p2"&gt;$9.99&lt;/span&gt;&lt;span id="p3"&gt;$5.00&lt;/span&gt;" String.prototype.split()字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。1str.split(separator, [limit]); 该方法接受两个参数，第一个参数可以是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。1234567891011// 非正则分隔'a, b,c, d'.split(',')// [ 'a', ' b', 'c', ' d' ]// 正则分隔，去除多余的空格'a, b,c, d'.split(/, */)// [ 'a', 'b', 'c', 'd' ]// 指定返回数组的最大成员'a, b,c, d'.split(/, */, 2)[ 'a', 'b' ] 正则语法字面量字符和元字符大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”（literal characters）。1/dog/.test('old dog') // true 点字符（.）点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。注意，对于码点大于0xFFFF字符，点字符不能正确匹配，会认为这是两个字符。 位置字符位置字符用来提示字符所处的位置，主要有两个字符。 ^ 表示字符串的开始位置 $ 表示字符串的结束位置 123456789/ test必须出现在开始位置/^test/.test('test123') // true// test必须出现在结束位置/test$/.test('new test') // true// 从开始位置到结束位置只有test/^test$/.test('test') // true/^test$/.test('test test') // false 选择符（|）竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。 转义符（\）正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠(\)。比如要匹配+，就要写成\+。正则表达式中，需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。12345/1+1/.test('1+1')// false/1\+1/.test('1+1')// true 12345(new RegExp('1\+1')).test('1+1')// false(new RegExp('1\\+1')).test('1+1')// true 上面代码中，RegExp作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。 特殊字符正则表达式对一些不能打印的特殊字符，提供了表达方法。 \cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。 [\b] 匹配退格键(U+0008)，不要与\b混淆。 \n 匹配换行键。 \r 匹配回车键。 \t 匹配制表符 tab（U+0009）。 \v 匹配垂直制表符（U+000B）。 \f 匹配换页符（U+000C）。 \0 匹配null字符（U+0000）。 \xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。 \uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符。 字符类字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。 脱字符（^）如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。 连字符（-）某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。以下都是合法的字符类简写形式。1234[0-9.,][0-9a-fA-F][a-zA-Z0-9-][1-31] 预定义模式预定义模式指的是某些常见模式的简写方式。 \d 匹配0-9之间的任一数字，相当于[0-9]。 \D 匹配所有0-9以外的字符，相当于[^0-9]。 \w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。 \W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。 \s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。 \S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。 \b 匹配词的边界。 \B 匹配非词边界，即在词的内部。 \b 和 \B 的匹配例子 1234567891011// \s 的例子/\s\w*/.exec('hello world') // [" world"]// \b 的例子/\bworld/.test('hello world') // true/\bworld/.test('hello-world') // true/\bworld/.test('helloworld') // false// \B 的例子/\Bworld/.test('hello-world') // false/\Bworld/.test('helloworld') // true 通常，正则表达式遇到换行符（\n）就会停止匹配。1234var html = "&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;";/.*/.exec(html)[0]// "&lt;b&gt;Hello&lt;/b&gt;" 上面代码中，字符串html包含一个换行符，结果点字符（.）不匹配换行符，导致匹配结果可能不符合原意。这时使用\s字符类，就能包括换行符。1234var html = "&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;";/[\S\s]*/.exec(html)[0]// "&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;" 上面代码中，[\S\s]指代一切字符。 重复类模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。12/lo&#123;2&#125;k/.test('look') // true/lo&#123;2,5&#125;k/.test('looook') // true 量词类量词符用来设定某个模式出现的次数。 ? 问号表示某个模式出现0次或1次，等同于{0, 1}。 * 星号表示某个模式出现0次或多次，等同于{0,}。 + 加号表示某个模式出现1次或多次，等同于{1,}。 贪婪模式上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。12var s = 'aaa';s.match(/a+/) // ["aaa"] 如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。12var s = 'aaa';s.match(/a+?/) // ["a"] 上面代码中，模式结尾添加了一个问号/a+?/，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配。所以非贪婪模式有： *?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。 +?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。 修饰符g 修饰符g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。12345678910111213// 不带 g 每次都是从字符串头部开始匹配var regex = /b/;var str = 'abba';regex.test(str); // trueregex.test(str); // trueregex.test(str); // true// 含有g修饰符，每次都是从上一次匹配成功的后一位，开始向后匹配var regex = /b/g;var str = 'abba';regex.test(str); // trueregex.test(str); // trueregex.test(str); // false i 修饰符默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。12/abc/.test('ABC') // false/abc/i.test('ABC') // true m 修饰符m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n）。12/world$/.test('hello world\n') // false/world$/m.test('hello world\n') // true 组匹配正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。12var m = 'abcabc'.match(/(.)b(.)/);m // ['abc', 'a', 'c'] 注意，使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容。12var m = 'abcabc'.match(/(.)b(.)/g);m // ['abc', 'abc'] 上面代码使用带g修饰符的正则表达式，结果match方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的exec方法，配合循环，才能读到每一轮匹配的组捕获。123456789var str = 'abcabc';var reg = /(.)b(.)/g;while (true) &#123; var result = reg.exec(str); if (!result) break; console.log(result);&#125;// ["abc", "a", "c"]// ["abc", "a", "c"] 正则表达式内部，还可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。12345/(.)b(.)\1b\2/.test("abcabc")// true// \1指向外层括号，\2指向内层括号。/y((..)\2)\1/.test('yabababab') // true 非捕获组?:x 非捕获组，表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。1234567891011121314var m = 'abc'.match(/(?:.)b(.)/);m // ["abc", "c"]// 正常匹配var url = /(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;url.exec('http://google.com/');// ["http://google.com/", "http", "google.com", "/"]// 非捕获组匹配var url = /(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;url.exec('http://google.com/');// ["http://google.com/", "google.com", "/"] 先行断言x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。12var m = 'abc'.match(/b(?=c)/);m // ["b"] 先行否定断言x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/12/\d+(?!\.)/.exec('3.14')// ["14"]]]></content>
      <tags>
        <tag>js原生</tag>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String]]></title>
    <url>%2F2018%2F07%2F17%2FString%2F</url>
    <content type="text"><![CDATA[概述String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。字符串对象是一个类似数组的对象（很像数组，但不是数组）。1234567var s1 = 'abc';var s2 = new String('abc');typeof s1 // "string"typeof s2 // "object"s2.valueOf() // "abc" 静态方法String.fromCharCode()String对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。1234String.fromCharCode() // ""String.fromCharCode(97) // "a"String.fromCharCode(104, 101, 108, 108, 111)// "hello" 实例属性String.prototype.charAt()charAt方法返回指定位置的字符，参数是从0开始编号的位置。如果参数为负数，或大于等于字符串的长度，返回空字符串。1234567var s = new String('abc');s.charAt(1) // "b"s.charAt(s.length - 1) // "c"'abc'.charAt(1) // "b"'abc'[1] // "b" String.prototype.charCodeAt()charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。1'abc'.charCodeAt(1) // 98 String.prototype.concat()concat方法用于连接两个或多个字符串，返回一个新字符串，不改变原字符串。1234567var s1 = 'abc';var s2 = 'def';s1.concat(s2) // "abcdef"s1 // "abc"'a'.concat('b', 'c') // "abc" String.prototype.slice()方法同数组的方法用法一致 String.prototype.substring()substring方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。1'JavaScript'.substring(0, 4) // "Java" 如果省略第二个参数，则表示子字符串一直到原字符串的结束。1'JavaScript'.substring(4) // "Script" 如果第一个参数大于第二个参数，substring方法会自动更换两个参数的位置。123JavaScript'.substring(10, 4) // "Script"// 等同于'JavaScript'.substring(4, 10) // "Script" 如果参数是负数，substring方法会自动将负数转为0。12'Javascript'.substring(-3) // "JavaScript"'JavaScript'.substring(4, -3) // "Java" String.prototype.substr()substr方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度。如果省略第二个参数，则表示子字符串一直到原字符串的结束。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。1'JavaScript'.substr(4, 6) // "Script" String.prototype.indexOf()，String.prototype.lastIndexOf()indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。 String.prototype.trim()trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。该方法去除的不仅是空格，还包括 制表符（\t、\v）、换行符（\n）和 回车符（\r）。12' hello world '.trim()// "hello world" String.prototype.toLowerCase()，String.prototype.toUpperCase()toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。12345'Hello World'.toLowerCase()// "hello world"'Hello World'.toUpperCase()// "HELLO WORLD" String.prototype.match()match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。12'cat, bat, sat, fat'.match('at') // ["at"]'cat, bat, sat, fat'.match('xt') // null 返回的数组还有index属性和input属性，分别表示匹配字符串开始的位置和原始字符串。123var matches = 'cat, bat, sat, fat'.match('at');matches.index // 1matches.input // "cat, bat, sat, fat" match方法还可以使用正则表达式作为参数 String.prototype.search()，String.prototype.replace()search方法的用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）12'cat, bat, sat, fat'.search('at') // 1'aaa'.replace('a', 'b') // "baa" String.prototype.split()split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。123'a|b|c'.split('|') // ["a", "b", "c"]'a|b|c'.split('') // ["a", "|", "b", "|", "c"] split方法还可以接受第二个参数，限定返回数组的最大成员数。]]></content>
      <tags>
        <tag>js原生</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Number]]></title>
    <url>%2F2018%2F07%2F17%2FNumber%2F</url>
    <content type="text"><![CDATA[Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。作为构造函数时，它用于生成值为数值的对象。12var n = new Number(1);typeof n // &quot;object&quot; 作为工具函数时，它可以将任何类型的值转为数值。1Number(true) // 1 实例方法Number.prototype.toString()Number对象部署了自己的toString方法，用来将一个数值转为字符串形式。1(10).toString() // &quot;10&quot; toString方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。123456(10).toString(2) // &quot;1010&quot;(10).toString(8) // &quot;12&quot;(10).toString(16) // &quot;a&quot;// 防止小数点识别错误 10[&apos;toString&apos;](2) // &quot;1010&quot; Number.prototype.toFixed()toFixed方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。12(10).toFixed(2) // &quot;10.00&quot;10.005.toFixed(2) // &quot;10.01&quot; toFixed方法的参数为小数位数，有效范围为0到20，超出这个范围将抛出 RangeError 错误。 Number.prototype.toPrecision()toPrecision方法用于将一个数转为指定位数的有效数字。12345(12.34).toPrecision(1) // &quot;1e+1&quot;(12.34).toPrecision(2) // &quot;12&quot;(12.34).toPrecision(3) // &quot;12.3&quot;(12.34).toPrecision(4) // &quot;12.34&quot;(12.34).toPrecision(5) // &quot;12.340&quot; 自定义方法1234Number.prototype.add = function (x) &#123; return this + x;&#125;;8[&apos;add&apos;](2) // 10]]></content>
      <categories>
        <category>js原生</category>
        <category>Number</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>Number</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包装对象]]></title>
    <url>%2F2018%2F07%2F17%2F%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[定义所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。1234567891011var v1 = new Number(123);var v2 = new String('abc');var v3 = new Boolean(true);typeof v1 // "object"typeof v2 // "object"typeof v3 // "object"v1 === 123 // falsev2 === 'abc' // falsev3 === true // false 三种包装对象各自提供了许多实例方法，详见后文。这里介绍两种它们共同具有、从Object对象继承的方法：valueOf和toString。 valueOf()valueOf方法返回包装对象实例对应的原始类型的值。123new Number(123).valueOf() // 123new String('abc').valueOf() // "abc"new Boolean(true).valueOf() // true toString()toString方法返回对应的字符串形式。new Number(123).toString() // “123”new String(‘abc’).toString() // “abc”new Boolean(true).toString() // “true” 原始类型与实例对象的自动转换原始类型的值，可以自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。 比如，字符串可以调用length属性，返回字符串的长度。123456789var str = 'abc';str.length // 3// 等同于var strObj = new String(str)// String &#123;// 0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"// &#125;strObj.length // 3 自定义方法除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用。12345678910111213String.prototype.double = function () &#123; return this.valueOf() + this.valueOf();&#125;;'abc'.double()// abcabcNumber.prototype.double = function () &#123; return this.valueOf() + this.valueOf();&#125;;(123).double() // 123外面必须要加上圆括号，否则后面的点运算符（.）会被解释成小数点。// 246]]></content>
      <categories>
        <category>js原生</category>
        <category>包装对象</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>包装对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array]]></title>
    <url>%2F2018%2F07%2F17%2FArray%2F</url>
    <content type="text"><![CDATA[构造函数Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。123var arr = new Array(2);arr.length // 2arr // [ empty x 2 ] 如果没有使用new，运行结果也是一样的。123var arr = new Array(2);// 等同于var arr = Array(2); Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。12345678910111213141516171819// 无参数时，返回一个空数组new Array() // []// 单个正整数参数，表示返回的新数组的长度new Array(1) // [ empty ]new Array(2) // [ empty x 2 ]// 非正整数的数值作为参数，会报错new Array(3.2) // RangeError: Invalid array lengthnew Array(-3) // RangeError: Invalid array length// 单个非数值（比如字符串、布尔值、对象等）作为参数，// 则该参数是返回的新数组的成员new Array('abc') // ['abc']new Array([1]) // [Array[1]]// 多参数时，所有参数都是返回的新数组的成员new Array(1, 2) // [1, 2]new Array('a', 'b', 'c') // ['a', 'b', 'c'] 可以看到，Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。 静态方法Array.isArray()1234var arr = [1, 2, 3];typeof arr // "object"// 它可以弥补typeof运算符的不足。Array.isArray(arr) // true 实例方法valueOf()valueOf方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。 toString()toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。 push()push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 pop()pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组；对空数组使用pop方法，不会报错，而是返回undefined.1[].pop() // undefined push和pop结合使用，就构成了“后进先出”的栈结构（stack）。 shift()shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。 unshift()unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 join()join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔;如果数组成员是undefined或null或空位，会被转成空字符串。 concat()concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。 reverse()reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。 slice()slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。它的第一个参数为起始位置（从0开始）， 第二个参数为终止位置（但该位置的元素本身不包括在内）。 如果省略第二个参数，则一直返回到原数组的最后一个成员。没有参数，实际上等于返回一个原数组的拷贝。 如果slice方法的参数是负数，则表示倒数计算的位置。 如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。 splice()arr.splice(start, count, addElement1, addElement2, ...);splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。 splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 如果只是单纯地插入元素，splice方法的第二个参数可以设为0。 sort()sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。1234567891011121314151617[10111, 1101, 111].sort(function (a, b) &#123; return a - b;&#125;)// [111, 1101, 10111][ &#123; name: "张三", age: 30 &#125;, &#123; name: "李四", age: 24 &#125;, &#123; name: "王五", age: 28 &#125;].sort(function (o1, o2) &#123; return o1.age - o2.age;&#125;)// [// &#123; name: "李四", age: 24 &#125;,// &#123; name: "王五", age: 28 &#125;,// &#123; name: "张三", age: 30 &#125;// ] 上面代码中，sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。 map()map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。map方法的回调函数有三个参数，elem为当前成员的值，index为当前成员的位置，arr为原数组map方法还可以接受第二个参数，用来绑定回调函数内部的this变量 forEach()forEach方法不返回值，只用来循环操作数据。forEach方法也可以接受第二个参数，绑定参数函数的this变量forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。 filter()filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。filter方法还可以接受第二个参数，用来绑定参数函数内部的this变量。 some()接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。注意，对于空数组，some方法返回false，some方法是只要一个成员的返回值是true,则返回true every()用法同 some()every方法是所有成员的返回值都是true,则返回true注意，对于空数组，every方法返回true，回调函数都不会执行。 reduce()第一个参数都是一个函数。该函数接受以下四个参数。 累积变量，默认为数组的第一个成员 当前变量，默认为数组的第二个成员 当前位置（从0开始） 原数组 这四个参数之中，只有前两个是必须的，后两个则是可选的。123456789101112131415[1, 2, 3, 4, 5].reduce(function (a, b) &#123; console.log(a, b); return a + b;&#125;)// 1 2// 3 3// 6 4// 10 5//最后结果：15// 第二个参数 指定初始值[1, 2, 3, 4, 5].reduce(function (a, b) &#123; return a + b;&#125;, 10);// 25 reduceRight()reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。 indexOf()，lastIndexOf()indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1.indexOf方法还可以接受第二个参数，表示搜索的开始位置。lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1.注意，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。]]></content>
      <categories>
        <category>js原生</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[属性描述对象]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%B1%9E%E6%80%A7%E8%A1%A8%E8%BF%B0%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[概述JavaScript 提供了一个内部数据结构，用来表述对象的属性，控制它的行为。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。下面是属性描述对象的一个例子。123456789&#123; configurable:true, enumerable:true, value:1, writable:true, __proto__:Object, // 可称为隐式原型 一个对象实例通过内部属性[[Prototype]]跟踪其原型对象。 get:undefined, set:undefined&#125; 在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。即：对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。方法这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。具体如下图所示:上图表述： 构造函数Foo()构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。 原型对象Foo.prototypeFoo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。 实例f1和f2是Foo这个对象的两个实例，这两个对象也有属性proto，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。 Foo()除了是方法，也是对象啊，它也有proto属性，指向谁呢？指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的proto指向了Function.prototype。其实除了Foo()，Function(), Object()也是一样的道理。 原型对象也是对象啊，它的proto属性，又指向谁呢？同理，指向它的构造函数的原型对象呗。这里是Object.prototype. 最后，Object.prototype的proto属性指向null。 属性描述对象6个元属性 value： 该属性的属性值 writable：表示属性值（value）是否可改变（即是否可写），默认为true。 enumerable：布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。 configurable：布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。 get：函数，表示该属性的取值函数（getter），默认为undefined set：函数，表示该属性的存值函数（setter），默认为undefined。 描述符可同时具有的键值 configurable enumerable value writable get set 数据描述符 yes yes yes yes no no 存取描述符 yes yes no no yes yes Object.getOwnPropertyDescriptor()Object.getOwnPropertyDescriptor方法可以获取属性描述对象。它的第一个参数是一个对象，第二个参数是一个字符串，对应该对象的某个属性名。注意，Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性。12345678var obj = &#123; p: 'a' &#125;;Object.getOwnPropertyDescriptor(obj, 'p')// Object &#123; value: "a",// writable: true,// enumerable: true,// configurable: true// &#125; Object.getOwnPropertyNames()Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。 Object.defineProperty()，Object.defineProperties()Object.defineProperty(object, propertyName, attributesObject) object：属性所在的对象 propertyName：属性名（它应该是一个字符串） attributesObject：属性描述对象 1234567891011var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 123, writable: false, enumerable: true, configurable: false&#125;);obj.p // 123obj.p = 246;obj.p // 123 如果一次性定义或修改多个属性，可以使用Object.defineProperties方法。123456789101112var obj = Object.defineProperties(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true &#125;, p2: &#123; value: 'abc', enumerable: true &#125;, p3: &#123; get: function () &#123; return this.p1 + this.p2 &#125;, enumerable:true, configurable:true &#125;&#125;);obj.p1 // 123obj.p2 // "abc"obj.p3 // "123abc" Object.prototype.propertyIsEnumerable()实例对象的propertyIsEnumerable方法返回一个布尔值，用来判断某个属性是否可遍历。12345var obj = &#123;&#125;;obj.p = 123;obj.propertyIsEnumerable('p') // trueobj.propertyIsEnumerable('toString') // false 原属性valuevalue 目标属性的值12345678var obj = &#123;&#125;;obj.p = 123;Object.getOwnPropertyDescriptor(obj, 'p').value// 123Object.defineProperty(obj, 'p', &#123; value: 246 &#125;);obj.p // 246 writablewritable属性是一个布尔值，决定了目标属性的值（value）是否可以被改变。注意：严格模式下，writable为false的属性赋值会报错。12345678910var obj = &#123;&#125;;Object.defineProperty(obj, 'a', &#123; value: 37, writable: false&#125;);obj.a // 37obj.a = 25;obj.a // 37 如果原型对象的某个属性的writable为false，那么子对象将无法自定义这个属性。123456789var proto = Object.defineProperty(&#123;&#125;, 'foo', &#123; value: 'a', writable: false&#125;);var obj = Object.create(proto);obj.foo = 'b';obj.foo // 'a' 上面代码中，proto是原型对象，它的foo属性不可写。obj对象继承proto，也不可以再自定义这个属性了。如果是严格模式，这样做还会抛出一个错误。 但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。1234567891011var proto = Object.defineProperty(&#123;&#125;, 'foo', &#123; value: 'a', writable: false&#125;);var obj = Object.create(proto);Object.defineProperty(obj, 'foo', &#123; value: 'b'&#125;);obj.foo // "b" enumerableenumerable（可遍历性）返回一个布尔值，表示目标属性是否可遍历。具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。 for..in循环 Object.keys方法 JSON.stringify方法 因此，enumerable可以用来设置“秘密”属性。1234567891011121314var obj = &#123;&#125;;Object.defineProperty(obj, 'x', &#123; value: 123, enumerable: false&#125;);obj.x // 123for (var key in obj) &#123; console.log(key);&#125;// undefinedObject.keys(obj) // []JSON.stringify(obj) // "&#123;&#125;" configurableconfigurable(可配置性）返回一个布尔值，决定了是否可以修改属性描述对象。12345678910111213141516171819var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 1, writable: false, enumerable: false, configurable: false&#125;);Object.defineProperty(obj, 'p', &#123;value: 2&#125;)// TypeError: Cannot redefine property: p// 只要`writable`和`configurable`有一个为true，就允许改动value。Object.defineProperty(obj, 'p', &#123;writable: true&#125;)// TypeError: Cannot redefine property: pObject.defineProperty(obj, 'p', &#123;enumerable: true&#125;)// TypeError: Cannot redefine property: pObject.defineProperty(obj, 'p', &#123;configurable: true&#125;)// TypeError: Cannot redefine property: p 注意，writable只有在false改为true会报错，true改为false是允许的。至于value，只要writable和configurable有一个为true，就允许改动。另外，configurable为false时，直接目标属性赋值，不报错，但不会成功。 setter，getter取值函数get不能接受参数，存值函数set只能接受一个参数（即属性的值。存取器往往用于，属性的值依赖对象内部数据的场合。1234567891011121314151617181920212223242526272829303132333435var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; get: function () &#123; return 'getter'; &#125;, set: function (value) &#123; console.log('setter: ' + value); &#125;&#125;);obj.p // "getter"obj.p = 123 // "setter: 123"// es6 写法var obj = &#123; get p() &#123; return 'getter'; &#125;, set p(value) &#123; console.log('setter: ' + value); &#125;&#125;;var obj =&#123; $n : 5, get next() &#123; return this.$n++ &#125;, set next(n) &#123; if (n &gt;= this.$n) this.$n = n; else throw new Error('新的值必须大于当前值'); &#125;&#125;;obj.next // 5obj.next = 10;obj.next // 10obj.next = 5;// Uncaught Error: 新的值必须大于当前值// next属性的存值函数和取值函数，都依赖于内部属性$n 对象的拷贝有时，我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现。1234567var extend = function (to, from) &#123; for (var property in from) &#123; to[property] = from[property]; &#125; return to;&#125; 上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值。1234extend(&#123;&#125;, &#123; get a() &#123; return 1 &#125;&#125;)// &#123;a: 1&#125; 为了解决这个问题，我们可以通过Object.defineProperty方法来拷贝属性。12345678910111213var extend = function (to, from) &#123; for (var property in from) &#123; //过滤掉继承的属性 if (!from.hasOwnProperty(property)) continue; Object.defineProperty( to, property, Object.getOwnPropertyDescriptor(from, property) ); &#125; return to;&#125;extend(&#123;&#125;, &#123; get a()&#123; return 1 &#125; &#125;) 控制对象状态有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。 Object.preventExtensions()Object.preventExtensions方法可以使得一个对象无法再添加新的属性。 Object.isExtensible()Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。也就是说，检查是否可以为一个对象添加属性。 Object.seal()Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。Object.seal实质是把属性描述对象的configurable属性设为false，因此属性描述对象不再能改变了。Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值(writable还为true)。 Object.isSealed()Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。这时，Object.isExtensible方法也返回false。 Object.freeze()Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。 Object.isFrozen()使用Object.freeze方法以后，Object.isSealed将会返回true，Object.isExtensible返回false。 局限性上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。1234567var obj = new Object();Object.preventExtensions(obj);var proto = Object.getPrototypeOf(obj);proto.t = 'hello';obj.t// hello 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。12345678var obj = &#123; foo: 1, bar: ['a', 'b']&#125;;Object.freeze(obj);obj.bar.push('c');obj.bar // ["a", "b", "c"]]]></content>
      <categories>
        <category>js原生</category>
        <category>Object</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>属性表述对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object]]></title>
    <url>%2F2018%2F07%2F16%2FObject%2F</url>
    <content type="text"><![CDATA[概述JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。 Object 对象本身的方法所谓”本身的方法“就是直接定义在Object对象的方法。1Object.print = function (o) &#123; console.log(o) &#125;; Object的实例方法所谓实例方法就是定义在Object原型对象Object.prototype上的方法。它可以被Object实例直接使用。123456Object.prototype.print = function () &#123; console.log(this);&#125;;var obj = new Object();obj.print() // Object Object 构造函数Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。 Object 用作工具函数1234567891011121314151617181920212223242526272829303132var obj = Object();// 等同于var obj = Object(undefined);var obj = Object(null);obj instanceof Object // true// 参数为原始诗句类型var obj = Object(1);obj instanceof Object // trueobj instanceof Number // truevar obj = Object('foo');obj instanceof Object // trueobj instanceof String // truevar obj = Object(true);obj instanceof Object // trueobj instanceof Boolean // true// 参数为复杂数据类型var arr = [];var obj = Object(arr); // 返回原数组obj === arr // truevar value = &#123;&#125;;var obj = Object(value) // 返回原对象obj === value // truevar fn = function () &#123;&#125;;var obj = Object(fn); // 返回原函数obj === fn // true 利用工具函数 判断变量是否为对象的函数。123456function isObject(value) &#123; return value === Object(value);&#125;isObject([]) // trueisObject(true) // false Object构造函数的用法Object构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象.123456var o1 = &#123;a: 1&#125;;var o2 = new Object(o1);o1 === o2 // truevar obj = new Object(123);obj instanceof Number // true Object 的静态方法所谓“静态方法”，是指部署在Object对象自身的方法。 Object.keys（）Object.keys方法的参数是一个对象，返回一个数组。其元素来自于从给定的object上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。123456var obj = &#123; p1: 123, p2: 456&#125;;Object.keys(obj) // ["p1", "p2"] Object.getOwnPropertyNames与Object.keys类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。 其他方法对象属性模型的相关方法 Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。 Object.defineProperty()：通过描述对象，定义某个属性。 Object.defineProperties()：通过描述对象，定义多个属性。控制对象状态的方法 Object.preventExtensions()：防止对象扩展。 Object.isExtensible()：判断对象是否可扩展。 Object.seal()：禁止对象配置。 Object.isSealed()：判断一个对象是否可配置。 Object.freeze()：冻结一个对象。 Object.isFrozen()：判断一个对象是否被冻结。原型链相关方法 Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。 Object.getPrototypeOf()：获取对象的Prototype对象。 Object 的实例方法除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。 Object.prototype.valueOf()：返回当前对象对应的值。 Object.prototype.toString()：返回当前对象对应的字符串形式。 Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。 Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性 Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。 Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。 Object.prototype.valueOf()valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。valueOf方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法。123456789101112var obj = new Object();obj.valueOf() === obj // truevar obj = new Object();1 + obj // "1[object Object]"// 如果自定义valueOf方法，就可以得到想要的结果。var obj = new Object();obj.valueOf = function () &#123; return 2;&#125;;1 + obj // 3 Object.prototype.toString()toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。对于一个对象调用toString方法，会返回字符串[object Object];字符串[object Object]本身没有太大的用处，但是通过自定义toString方法，可以让对象在自动类型转换时，得到想要的字符串形式。数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。1234567891011121314151617181920212223242526var o1 = new Object();o1.toString() // "[object Object]"var o2 = &#123;a:1&#125;;o2.toString() // "[object Object]"var obj = new Object();obj.toString = function () &#123; return 'hello';&#125;;obj + ' ' + 'world' // "hello world"// 其他数据类型的 toString方法。[1, 2, 3].toString() // "1,2,3"'123'.toString() // "123"(function () &#123; return 123;&#125;).toString()// "function () &#123;// return 123;// &#125;"(new Date()).toString()// "Tue May 10 2016 09:11:31 GMT+0800 (CST)" toString() 的应用：判断数据类型Object.prototype.toString方法返回对象的类型字符串，因此可以用来判断一个值的类型。由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法。1234567891011121314151617181920212223var type = function (o)&#123; var s = Object.prototype.toString.call(o); return s.match(/\[object (.*?)\]/)[1].toLowerCase();&#125;;['Null','Undefined','Object','Array','String','Number','Boolean','Function','RegExp'].forEach(function (t) &#123; type['is' + t] = function (o) &#123; return type(o) === t.toLowerCase(); &#125;;&#125;);type.isObject(&#123;&#125;) // truetype.isNumber(NaN) // truetype.isRegExp(/abc/) // true Object.prototype.toLocaleString()这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的toLocaleString，用来返回针对某些地域的特定的值。1234567var obj = &#123;&#125;;obj.toString(obj) // "[object Object]"obj.toLocaleString(obj) // "[object Object]"var date = new Date();date.toString() // "Tue Jan 01 2018 12:01:33 GMT+0800 (CST)"date.toLocaleString() // "1/01/2018, 12:01:33 PM" Object.prototype.hasOwnProperty()Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。12345var obj = &#123; p: 123&#125;;obj.hasOwnProperty('p') // trueobj.hasOwnProperty('toString') // false]]></content>
      <categories>
        <category>js原生</category>
        <category>Object</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误处理机制]]></title>
    <url>%2F2018%2F07%2F15%2F%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Error 实例对象JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。12var err = new Error('出错了');err.message // "出错了" error 实例的属性和方法 message：错误提示信息 错误名称（非标准属性 stack：错误的堆栈（非标准属性） 1234567891011121314151617function throwit() &#123; throw new Error('');&#125;function catchit() &#123; try &#123; throwit(); &#125; catch(e) &#123; console.log(e.stack); // print stack trace &#125;&#125;// 错误堆栈的最内层是throwit函数，然后是catchit函数，最后是函数的运行环境。catchit()// Error// at throwit (~/examples/throwcatch.js:9:11)// at catchit (~/examples/throwcatch.js:3:9)// at repl:1:5 原生错误类型 Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。 SyntaxError 对象SyntaxError对象是解析代码时发生的语法错误。1234567// 变量名错误var 1a;// Uncaught SyntaxError: Invalid or unexpected token// 缺少括号console.log 'hello');// Uncaught SyntaxError: Unexpected string ReferenceError 对象referenceError对象是引用一个不存在的变量时发生的错误。123// 使用一个不存在的变量unknownVariable// Uncaught ReferenceError: unknownVariable is not defined RangeError 对象RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。123// 数组长度不得为负数new Array(-1)// Uncaught RangeError: Invalid array length TypeError 对象TypeError对象是变量或参数不是预期类型时发生的错误。123var obj = &#123;&#125;;obj.unknownMethod()// Uncaught TypeError: obj.unknownMethod is not a function URIError 对象URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。12decodeURI('%2')// URIError: URI malformed EvalError 对象eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。 自定义错误类型除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。1234567function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError; throw语句throw语句的作用是手动中断程序执行，抛出一个错误。1234if (x &lt; 0) &#123; throw new Error('x 必须为正数');&#125;// Uncaught ReferenceError: x is not defined throw 可抛出任意类型的值1234567891011121314151617181920212223// 抛出一个字符串throw 'Error！'; // Uncaught Error！// 抛出一个数值throw 42; // Uncaught 42// 抛出一个布尔值throw true; // Uncaught true// 抛出一个对象throw &#123; toString: function () &#123; return 'Error!'; &#125;&#125;; // // Uncaught &#123;toString: ƒ&#125;// 抛出一个自定义错误function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;throw new UserError('出错了！'); // Uncaught UserError &#123;message: "出错了！", name: "UserError"&#125; try…catch 结构一旦发生错误，程序就中止执行了。JavaScript 提供了try...catch结构，允许对错误进行处理，选择是否往下执行。123456789try &#123; throw new Error('出错了!');&#125; catch (e) &#123; console.log(e.name + ": " + e.message); console.log(e.stack);&#125;// Error: 出错了!// at &lt;anonymous&gt;:3:9// ... catch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。123456789try &#123; throw "出错了";&#125; catch (e) &#123; console.log(111);&#125; // 被catch代码块捕获后，程序会继续向下执行console.log(222); // 111// 222 catch代码块之中，还可以再抛出错误，甚至使用嵌套的try…catch结构1234567891011var n = 100;try &#123; throw n;&#125; catch (e) &#123; if (e &lt;= 50) &#123; // ... &#125; else &#123; throw e; &#125;&#125; finallytry…catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。123456789101112131415161718192021222324252627282930313233343536373839404142434445 function f() &#123; try &#123; console.log(0); throw 'bug'; &#125; catch(e) &#123; console.log(1); return true; // 这句原本会延迟到 finally 代码块结束再执行 console.log(2); // 不会运行 &#125; finally &#123; console.log(3); return false; // 这句会覆盖掉前面那句 return console.log(4); // 不会运行 &#125; console.log(5); // 不会运行 &#125; var result = f(); // 0 // 1 // 3 result // falsefunction f() &#123; try &#123; throw '出错了！'; &#125; catch(e) &#123; console.log('捕捉到内部错误'); throw e; // 这句原本会等到finally结束再执行 &#125; finally &#123; return false; // 直接返回 &#125;&#125;try &#123; f();&#125; catch(e) &#123; // 此处不会执行 console.log('caught outer "bogus"');&#125;// 捕捉到内部错误]]></content>
      <categories>
        <category>js原生</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[function]]></title>
    <url>%2F2018%2F07%2F15%2Ffunction%2F</url>
    <content type="text"><![CDATA[函数的声明函数 有三种申明方式： function 命令 函数表达式 Function 构造函数 function 命令123function print(s) &#123; console.log(s);&#125; 函数表达式采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体 外部无效。12345678var print = function(s) &#123; console.log(s);&#125;;var print = function x()&#123; // x 只能在此函数内部使用 console.log(typeof x);&#125;; Function最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。12345678910var add = new Function( 'x', 'y', 'return x + y');// 等同于function add(x, y) &#123; return x + y;&#125; 函数的属性和方法name属性返回函数的名字12345678910function f1() &#123;&#125;f1.name // "f1"var f2 = function () &#123;&#125;;f2.name // "f2"var f3 = function myName() &#123;&#125;;// 返回 function命令后 函数名f3.name // 'myName' length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。123// 不管调用时输入了多少个参数，length属性始终等于2。function f(a, b) &#123;&#125;f.length // 2 函数的参数参数的传递方式 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部；如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference） arguments 对象arguments读取函数调用时传入函数内部所有的参数，arguments为只读对象(伪数组)1234var args = Array.prototype.slice.call(arguments);// ES6var argus = Array.from(arguments) calleearguments对象带有一个callee属性，返回它所对应的原函数;可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。 函数的其他特性闭包闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它的诞生环境一直存在。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。123456789101112function createIncrementor(start) &#123; // 为了在函数外部读取 start的值 将 start的 值返回 return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);// inc使得函数createIncrementor的内部环境，一直存在于内存中。所以，闭包可以看作是函数内部作用域的一个接口。inc() // 5inc() // 6inc() // 7]]></content>
      <categories>
        <category>js原生</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>function</tag>
      </tags>
  </entry>
</search>
