<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Object]]></title>
    <url>%2F2018%2F07%2F16%2FObject%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[错误处理机制]]></title>
    <url>%2F2018%2F07%2F15%2F%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[文章目录 文章目录 Error 实例对象 error 实例的属性和方法 原生错误类型 SyntaxError 对象 ReferenceError 对象 RangeError 对象 TypeError 对象 URIError 对象 EvalError 对象 自定义错误类型 throw语句 try…catch 结构 finally Error 实例对象JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。12var err = new Error('出错了');err.message // "出错了" error 实例的属性和方法 message：错误提示信息 错误名称（非标准属性 stack：错误的堆栈（非标准属性） 1234567891011121314151617function throwit() &#123; throw new Error('');&#125;function catchit() &#123; try &#123; throwit(); &#125; catch(e) &#123; console.log(e.stack); // print stack trace &#125;&#125;// 错误堆栈的最内层是throwit函数，然后是catchit函数，最后是函数的运行环境。catchit()// Error// at throwit (~/examples/throwcatch.js:9:11)// at catchit (~/examples/throwcatch.js:3:9)// at repl:1:5 原生错误类型 Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。 SyntaxError 对象SyntaxError对象是解析代码时发生的语法错误。1234567// 变量名错误var 1a;// Uncaught SyntaxError: Invalid or unexpected token// 缺少括号console.log 'hello');// Uncaught SyntaxError: Unexpected string ReferenceError 对象referenceError对象是引用一个不存在的变量时发生的错误。123// 使用一个不存在的变量unknownVariable// Uncaught ReferenceError: unknownVariable is not defined RangeError 对象RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。123// 数组长度不得为负数new Array(-1)// Uncaught RangeError: Invalid array length TypeError 对象TypeError对象是变量或参数不是预期类型时发生的错误。123var obj = &#123;&#125;;obj.unknownMethod()// Uncaught TypeError: obj.unknownMethod is not a function URIError 对象URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。12decodeURI('%2')// URIError: URI malformed EvalError 对象eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。 自定义错误类型除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。1234567function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError; throw语句throw语句的作用是手动中断程序执行，抛出一个错误。1234if (x &lt; 0) &#123; throw new Error('x 必须为正数');&#125;// Uncaught ReferenceError: x is not defined throw 可抛出任意类型的值1234567891011121314151617181920212223// 抛出一个字符串throw 'Error！'; // Uncaught Error！// 抛出一个数值throw 42; // Uncaught 42// 抛出一个布尔值throw true; // Uncaught true// 抛出一个对象throw &#123; toString: function () &#123; return 'Error!'; &#125;&#125;; // // Uncaught &#123;toString: ƒ&#125;// 抛出一个自定义错误function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;throw new UserError('出错了！'); // Uncaught UserError &#123;message: "出错了！", name: "UserError"&#125; try…catch 结构一旦发生错误，程序就中止执行了。JavaScript 提供了try...catch结构，允许对错误进行处理，选择是否往下执行。123456789try &#123; throw new Error('出错了!');&#125; catch (e) &#123; console.log(e.name + ": " + e.message); console.log(e.stack);&#125;// Error: 出错了!// at &lt;anonymous&gt;:3:9// ... catch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。123456789try &#123; throw "出错了";&#125; catch (e) &#123; console.log(111);&#125; // 被catch代码块捕获后，程序会继续向下执行console.log(222); // 111// 222 catch代码块之中，还可以再抛出错误，甚至使用嵌套的try…catch结构1234567891011var n = 100;try &#123; throw n;&#125; catch (e) &#123; if (e &lt;= 50) &#123; // ... &#125; else &#123; throw e; &#125;&#125; finallytry…catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。123456789101112131415161718192021222324252627282930313233343536373839404142434445 function f() &#123; try &#123; console.log(0); throw 'bug'; &#125; catch(e) &#123; console.log(1); return true; // 这句原本会延迟到 finally 代码块结束再执行 console.log(2); // 不会运行 &#125; finally &#123; console.log(3); return false; // 这句会覆盖掉前面那句 return console.log(4); // 不会运行 &#125; console.log(5); // 不会运行 &#125; var result = f(); // 0 // 1 // 3 result // falsefunction f() &#123; try &#123; throw '出错了！'; &#125; catch(e) &#123; console.log('捕捉到内部错误'); throw e; // 这句原本会等到finally结束再执行 &#125; finally &#123; return false; // 直接返回 &#125;&#125;try &#123; f();&#125; catch(e) &#123; // 此处不会执行 console.log('caught outer "bogus"');&#125;// 捕捉到内部错误]]></content>
      <categories>
        <category>js原生</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[function]]></title>
    <url>%2F2018%2F07%2F15%2Ffunction%2F</url>
    <content type="text"><![CDATA[函数的声明 function 命令 函数表达式 Function 函数的属性和方法 name属性 length属性 函数的参数 参数的传递方式 arguments 对象 callee 函数的其他特性 闭包 函数的声明函数 有三种申明方式： function 命令 函数表达式 Function 构造函数 function 命令123function print(s) &#123; console.log(s);&#125; 函数表达式采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体 外部无效。12345678var print = function(s) &#123; console.log(s);&#125;;var print = function x()&#123; // x 只能在此函数内部使用 console.log(typeof x);&#125;; Function最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。12345678910var add = new Function( 'x', 'y', 'return x + y');// 等同于function add(x, y) &#123; return x + y;&#125; 函数的属性和方法name属性返回函数的名字12345678910function f1() &#123;&#125;f1.name // "f1"var f2 = function () &#123;&#125;;f2.name // "f2"var f3 = function myName() &#123;&#125;;// 返回 function命令后 函数名f3.name // 'myName' length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。123// 不管调用时输入了多少个参数，length属性始终等于2。function f(a, b) &#123;&#125;f.length // 2 函数的参数参数的传递方式 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部；如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference） arguments 对象arguments读取函数调用时传入函数内部所有的参数，arguments为只读对象(伪数组)1234var args = Array.prototype.slice.call(arguments);// ES6var argus = Array.from(arguments) calleearguments对象带有一个callee属性，返回它所对应的原函数;可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。 函数的其他特性闭包闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它的诞生环境一直存在。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。123456789101112function createIncrementor(start) &#123; // 为了在函数外部读取 start的值 将 start的 值返回 return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);// inc使得函数createIncrementor的内部环境，一直存在于内存中。所以，闭包可以看作是函数内部作用域的一个接口。inc() // 5inc() // 6inc() // 7]]></content>
      <categories>
        <category>js原生</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[testMyBlog]]></title>
    <url>%2F2018%2F07%2F13%2FtestMyBlog%2F</url>
    <content type="text"><![CDATA[好好变浓提第一个测试博客ahhahhdddadeee 12window.alert("aaa")console.log("bbbb")]]></content>
      <categories>
        <category>js原生</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
