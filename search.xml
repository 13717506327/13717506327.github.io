<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面向对象编程]]></title>
    <url>%2F2018%2F07%2F18%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[RegExp]]></title>
    <url>%2F2018%2F07%2F17%2FRegExp%2F</url>
    <content type="text"><![CDATA[RegExp对象创建新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。1var regx = /xyz/; 另一种是使用RegExp构造函数；RegExp构造函数还可以接受第二个参数，表示修饰符1var regex = new RegExp('xyz'); 实例属性修饰符相关属性返回一个布尔值，表示对应的修饰符是否设置,三个属性都是只读的。 RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了 i 修饰符。 RegExp.prototype.global：返回一个布尔值，表示是否设置了 g 修饰符。 RegExp.prototype.multiline：返回一个布尔值，表示是否设置了 m 修饰符。 与修饰符无关的属性 RegExp.prototype.lastIndex：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义。 RegExp.prototype.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。1234var r = /abc/igm;r.lastIndex // 0r.source // "abc" 实例方法RegExp.prototype.test()正则实例对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。1/cat/.test('cats and dogs') // true 如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。123456789101112var r = /x/g;var s = '_x_x';r.lastIndex // 0r.test(s) // truer.lastIndex // 2r.test(s) // truer.lastIndex // 4// 字符串的第五个位置开始搜索，这个位置是没有字符的，所以返回false。r.test(s) // false 注意，带有g修饰符时，正则表达式内部会记住上一次的lastIndex属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误。123var r = /bb/g;r.test('bb') // truer.test('-bb-') // false RegExp.prototype.exec()正则实例对象的exec方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。123456var s = '_x_x';var r1 = /x/;var r2 = /y/;r1.exec(s) // ["x"]r2.exec(s) // null 如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。1234var s = '_x_x';var r = /_(x)/;r.exec(s) // ["_x", "x"] exec方法的返回数组还包含以下两个属性： input：整个原字符串。 index：整个模式匹配成功的开始位置（从0开始计数）。 12345var r = /a(b+)a/;var arr = r.exec('_abbba_aba_');arr // ["abbba", "bbb"]arr.index // 1arr.input // "_abbba_aba_" 如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。123456789101112131415161718192021var reg = /a/g;var str = 'abc_abc_abc'var r1 = reg.exec(str);r1 // ["a"]r1.index // 0reg.lastIndex // 1var r2 = reg.exec(str);r2 // ["a"]r2.index // 4reg.lastIndex // 5var r3 = reg.exec(str);r3 // ["a"]r3.index // 8reg.lastIndex // 9var r4 = reg.exec(str);r4 // nullreg.lastIndex // 0 利用g修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。1234567891011var reg = /a/g;var str = 'abc_abc_abc'while(true) &#123; var match = reg.exec(str); if (!match) break; console.log('#' + match.index + ':' + match[0]);&#125;// #0:a// #4:a// #8:a 字符串的实例方法字符串的实例方法之中，有4种与正则表达式有关。 String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。 String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。 String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。 String.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。 String.prototype.match()字符串实例对象的match方法对字符串进行正则匹配，返回匹配结果。123456var s = '_x_x';var r1 = /x/;var r2 = /y/;s.match(r1) // ["x"]s.match(r2) // null 从上面代码可以看到，字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。如果正则表达式带有 g 修饰符，则该方法与正则对象的 exec 方法行为不同，会一次性返回所有匹配成功的结果。12345var s = 'abba';var r = /a/g;// 会一次性返回所有匹配成功的结果。s.match(r) // ["a", "a"]r.exec(s) // ["a"] 设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。1234var r = /a|b/g;r.lastIndex = 7;'xaxb'.match(r) // ['a', 'b']r.lastIndex // 0 String.prototype.search()字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。12'_x_x'.search(/x/)// 1 String.prototype.replace()字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。1str.replace(search, replacement) 正则表达式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。123'aaa'.replace('a', 'b') // "baa"'aaa'.replace(/a/, 'b') // "baa"'aaa'.replace(/a/g, 'b') // "bbb" replace方法的一个应用，就是消除字符串首尾两端的空格。1234var str = ' #id div.class ';str.replace(/^\s+|\s+$/g, '')// "#id div.class" replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。 $&amp;：匹配的子字符串。 $`：匹配结果前面的文本。 $’：匹配结果后面的文本。 $n：匹配成功的第n组内容，n是从1开始的自然数。 $$: 指代美元符号$。12345678910'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1')// "world hello"'abc'.replace('b', '[$`-$&amp;-$\']')// "a[a-b-c]c"'3 and 5'.replace(/[0-9]+/g, function (match) &#123; return 2 * match;&#125;)// "6 and 10" 作为replace方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。1234567891011121314151617var prices = &#123; 'p1': '$1.99', 'p2': '$9.99', 'p3': '$5.00'&#125;;var template = '&lt;span id="p1"&gt;&lt;/span&gt;' + '&lt;span id="p2"&gt;&lt;/span&gt;' + '&lt;span id="p3"&gt;&lt;/span&gt;';template.replace( /(&lt;span id=")(.*?)("&gt;)(&lt;\/span&gt;)/g, function(match, $1, $2, $3, $4)&#123; return $1 + $2 + $3 + prices[$2] + $4; &#125;);// "&lt;span id="p1"&gt;$1.99&lt;/span&gt;&lt;span id="p2"&gt;$9.99&lt;/span&gt;&lt;span id="p3"&gt;$5.00&lt;/span&gt;" String.prototype.split()字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。1str.split(separator, [limit]); 该方法接受两个参数，第一个参数可以是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。1234567891011// 非正则分隔'a, b,c, d'.split(',')// [ 'a', ' b', 'c', ' d' ]// 正则分隔，去除多余的空格'a, b,c, d'.split(/, */)// [ 'a', 'b', 'c', 'd' ]// 指定返回数组的最大成员'a, b,c, d'.split(/, */, 2)[ 'a', 'b' ] 正则语法字面量字符和元字符大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”（literal characters）。1/dog/.test('old dog') // true 点字符（.）点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。注意，对于码点大于0xFFFF字符，点字符不能正确匹配，会认为这是两个字符。 位置字符位置字符用来提示字符所处的位置，主要有两个字符。 ^ 表示字符串的开始位置 $ 表示字符串的结束位置 123456789/ test必须出现在开始位置/^test/.test('test123') // true// test必须出现在结束位置/test$/.test('new test') // true// 从开始位置到结束位置只有test/^test$/.test('test') // true/^test$/.test('test test') // false 选择符（|）竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。 转义符（\）正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠(\)。比如要匹配+，就要写成\+。正则表达式中，需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。12345/1+1/.test('1+1')// false/1\+1/.test('1+1')// true 12345(new RegExp('1\+1')).test('1+1')// false(new RegExp('1\\+1')).test('1+1')// true 上面代码中，RegExp作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。 特殊字符正则表达式对一些不能打印的特殊字符，提供了表达方法。 \cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。 [\b] 匹配退格键(U+0008)，不要与\b混淆。 \n 匹配换行键。 \r 匹配回车键。 \t 匹配制表符 tab（U+0009）。 \v 匹配垂直制表符（U+000B）。 \f 匹配换页符（U+000C）。 \0 匹配null字符（U+0000）。 \xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。 \uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符。 字符类字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。 脱字符（^）如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。 连字符（-）某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。以下都是合法的字符类简写形式。1234[0-9.,][0-9a-fA-F][a-zA-Z0-9-][1-31] 预定义模式预定义模式指的是某些常见模式的简写方式。 \d 匹配0-9之间的任一数字，相当于[0-9]。 \D 匹配所有0-9以外的字符，相当于[^0-9]。 \w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。 \W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。 \s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。 \S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。 \b 匹配词的边界。 \B 匹配非词边界，即在词的内部。 \b 和 \B 的匹配例子 1234567891011// \s 的例子/\s\w*/.exec('hello world') // [" world"]// \b 的例子/\bworld/.test('hello world') // true/\bworld/.test('hello-world') // true/\bworld/.test('helloworld') // false// \B 的例子/\Bworld/.test('hello-world') // false/\Bworld/.test('helloworld') // true 通常，正则表达式遇到换行符（\n）就会停止匹配。1234var html = "&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;";/.*/.exec(html)[0]// "&lt;b&gt;Hello&lt;/b&gt;" 上面代码中，字符串html包含一个换行符，结果点字符（.）不匹配换行符，导致匹配结果可能不符合原意。这时使用\s字符类，就能包括换行符。1234var html = "&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;";/[\S\s]*/.exec(html)[0]// "&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;" 上面代码中，[\S\s]指代一切字符。 重复类模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。12/lo&#123;2&#125;k/.test('look') // true/lo&#123;2,5&#125;k/.test('looook') // true 量词类量词符用来设定某个模式出现的次数。 ? 问号表示某个模式出现0次或1次，等同于{0, 1}。 * 星号表示某个模式出现0次或多次，等同于{0,}。 + 加号表示某个模式出现1次或多次，等同于{1,}。 贪婪模式上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。12var s = 'aaa';s.match(/a+/) // ["aaa"] 如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。12var s = 'aaa';s.match(/a+?/) // ["a"] 上面代码中，模式结尾添加了一个问号/a+?/，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配。所以非贪婪模式有： *?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。 +?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。 修饰符g 修饰符g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。12345678910111213// 不带 g 每次都是从字符串头部开始匹配var regex = /b/;var str = 'abba';regex.test(str); // trueregex.test(str); // trueregex.test(str); // true// 含有g修饰符，每次都是从上一次匹配成功的后一位，开始向后匹配var regex = /b/g;var str = 'abba';regex.test(str); // trueregex.test(str); // trueregex.test(str); // false i 修饰符默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。12/abc/.test('ABC') // false/abc/i.test('ABC') // true m 修饰符m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n）。12/world$/.test('hello world\n') // false/world$/m.test('hello world\n') // true 组匹配正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。12var m = 'abcabc'.match(/(.)b(.)/);m // ['abc', 'a', 'c'] 注意，使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容。12var m = 'abcabc'.match(/(.)b(.)/g);m // ['abc', 'abc'] 上面代码使用带g修饰符的正则表达式，结果match方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的exec方法，配合循环，才能读到每一轮匹配的组捕获。123456789var str = 'abcabc';var reg = /(.)b(.)/g;while (true) &#123; var result = reg.exec(str); if (!result) break; console.log(result);&#125;// ["abc", "a", "c"]// ["abc", "a", "c"] 正则表达式内部，还可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。12345/(.)b(.)\1b\2/.test("abcabc")// true// \1指向外层括号，\2指向内层括号。/y((..)\2)\1/.test('yabababab') // true 非捕获组?:x 非捕获组，表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。1234567891011121314var m = 'abc'.match(/(?:.)b(.)/);m // ["abc", "c"]// 正常匹配var url = /(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;url.exec('http://google.com/');// ["http://google.com/", "http", "google.com", "/"]// 非捕获组匹配var url = /(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;url.exec('http://google.com/');// ["http://google.com/", "google.com", "/"] 先行断言x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。12var m = 'abc'.match(/b(?=c)/);m // ["b"] 先行否定断言x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/12/\d+(?!\.)/.exec('3.14')// ["14"]]]></content>
      <tags>
        <tag>js原生</tag>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String]]></title>
    <url>%2F2018%2F07%2F17%2FString%2F</url>
    <content type="text"><![CDATA[概述String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。字符串对象是一个类似数组的对象（很像数组，但不是数组）。1234567var s1 = 'abc';var s2 = new String('abc');typeof s1 // "string"typeof s2 // "object"s2.valueOf() // "abc" 静态方法String.fromCharCode()String对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。1234String.fromCharCode() // ""String.fromCharCode(97) // "a"String.fromCharCode(104, 101, 108, 108, 111)// "hello" 实例属性String.prototype.charAt()charAt方法返回指定位置的字符，参数是从0开始编号的位置。如果参数为负数，或大于等于字符串的长度，返回空字符串。1234567var s = new String('abc');s.charAt(1) // "b"s.charAt(s.length - 1) // "c"'abc'.charAt(1) // "b"'abc'[1] // "b" String.prototype.charCodeAt()charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。1'abc'.charCodeAt(1) // 98 String.prototype.concat()concat方法用于连接两个或多个字符串，返回一个新字符串，不改变原字符串。1234567var s1 = 'abc';var s2 = 'def';s1.concat(s2) // "abcdef"s1 // "abc"'a'.concat('b', 'c') // "abc" String.prototype.slice()方法同数组的方法用法一致 String.prototype.substring()substring方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。1'JavaScript'.substring(0, 4) // "Java" 如果省略第二个参数，则表示子字符串一直到原字符串的结束。1'JavaScript'.substring(4) // "Script" 如果第一个参数大于第二个参数，substring方法会自动更换两个参数的位置。123JavaScript'.substring(10, 4) // "Script"// 等同于'JavaScript'.substring(4, 10) // "Script" 如果参数是负数，substring方法会自动将负数转为0。12'Javascript'.substring(-3) // "JavaScript"'JavaScript'.substring(4, -3) // "Java" String.prototype.substr()substr方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度。如果省略第二个参数，则表示子字符串一直到原字符串的结束。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。1'JavaScript'.substr(4, 6) // "Script" String.prototype.indexOf()，String.prototype.lastIndexOf()indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。 String.prototype.trim()trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。该方法去除的不仅是空格，还包括 制表符（\t、\v）、换行符（\n）和 回车符（\r）。12' hello world '.trim()// "hello world" String.prototype.toLowerCase()，String.prototype.toUpperCase()toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。12345'Hello World'.toLowerCase()// "hello world"'Hello World'.toUpperCase()// "HELLO WORLD" String.prototype.match()match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。12'cat, bat, sat, fat'.match('at') // ["at"]'cat, bat, sat, fat'.match('xt') // null 返回的数组还有index属性和input属性，分别表示匹配字符串开始的位置和原始字符串。123var matches = 'cat, bat, sat, fat'.match('at');matches.index // 1matches.input // "cat, bat, sat, fat" match方法还可以使用正则表达式作为参数 String.prototype.search()，String.prototype.replace()search方法的用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）12'cat, bat, sat, fat'.search('at') // 1'aaa'.replace('a', 'b') // "baa" String.prototype.split()split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。123'a|b|c'.split('|') // ["a", "b", "c"]'a|b|c'.split('') // ["a", "|", "b", "|", "c"] split方法还可以接受第二个参数，限定返回数组的最大成员数。]]></content>
      <tags>
        <tag>js原生</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Number]]></title>
    <url>%2F2018%2F07%2F17%2FNumber%2F</url>
    <content type="text"><![CDATA[Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。作为构造函数时，它用于生成值为数值的对象。12var n = new Number(1);typeof n // &quot;object&quot; 作为工具函数时，它可以将任何类型的值转为数值。1Number(true) // 1 实例方法Number.prototype.toString()Number对象部署了自己的toString方法，用来将一个数值转为字符串形式。1(10).toString() // &quot;10&quot; toString方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。123456(10).toString(2) // &quot;1010&quot;(10).toString(8) // &quot;12&quot;(10).toString(16) // &quot;a&quot;// 防止小数点识别错误 10[&apos;toString&apos;](2) // &quot;1010&quot; Number.prototype.toFixed()toFixed方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。12(10).toFixed(2) // &quot;10.00&quot;10.005.toFixed(2) // &quot;10.01&quot; toFixed方法的参数为小数位数，有效范围为0到20，超出这个范围将抛出 RangeError 错误。 Number.prototype.toPrecision()toPrecision方法用于将一个数转为指定位数的有效数字。12345(12.34).toPrecision(1) // &quot;1e+1&quot;(12.34).toPrecision(2) // &quot;12&quot;(12.34).toPrecision(3) // &quot;12.3&quot;(12.34).toPrecision(4) // &quot;12.34&quot;(12.34).toPrecision(5) // &quot;12.340&quot; 自定义方法1234Number.prototype.add = function (x) &#123; return this + x;&#125;;8[&apos;add&apos;](2) // 10]]></content>
      <categories>
        <category>js原生</category>
        <category>Number</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>Number</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包装对象]]></title>
    <url>%2F2018%2F07%2F17%2F%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[定义所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。1234567891011var v1 = new Number(123);var v2 = new String('abc');var v3 = new Boolean(true);typeof v1 // "object"typeof v2 // "object"typeof v3 // "object"v1 === 123 // falsev2 === 'abc' // falsev3 === true // false 三种包装对象各自提供了许多实例方法，详见后文。这里介绍两种它们共同具有、从Object对象继承的方法：valueOf和toString。 valueOf()valueOf方法返回包装对象实例对应的原始类型的值。123new Number(123).valueOf() // 123new String('abc').valueOf() // "abc"new Boolean(true).valueOf() // true toString()toString方法返回对应的字符串形式。new Number(123).toString() // “123”new String(‘abc’).toString() // “abc”new Boolean(true).toString() // “true” 原始类型与实例对象的自动转换原始类型的值，可以自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。 比如，字符串可以调用length属性，返回字符串的长度。123456789var str = 'abc';str.length // 3// 等同于var strObj = new String(str)// String &#123;// 0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"// &#125;strObj.length // 3 自定义方法除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用。12345678910111213String.prototype.double = function () &#123; return this.valueOf() + this.valueOf();&#125;;'abc'.double()// abcabcNumber.prototype.double = function () &#123; return this.valueOf() + this.valueOf();&#125;;(123).double() // 123外面必须要加上圆括号，否则后面的点运算符（.）会被解释成小数点。// 246]]></content>
      <categories>
        <category>js原生</category>
        <category>包装对象</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>包装对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array]]></title>
    <url>%2F2018%2F07%2F17%2FArray%2F</url>
    <content type="text"><![CDATA[构造函数Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。123var arr = new Array(2);arr.length // 2arr // [ empty x 2 ] 如果没有使用new，运行结果也是一样的。123var arr = new Array(2);// 等同于var arr = Array(2); Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。12345678910111213141516171819// 无参数时，返回一个空数组new Array() // []// 单个正整数参数，表示返回的新数组的长度new Array(1) // [ empty ]new Array(2) // [ empty x 2 ]// 非正整数的数值作为参数，会报错new Array(3.2) // RangeError: Invalid array lengthnew Array(-3) // RangeError: Invalid array length// 单个非数值（比如字符串、布尔值、对象等）作为参数，// 则该参数是返回的新数组的成员new Array('abc') // ['abc']new Array([1]) // [Array[1]]// 多参数时，所有参数都是返回的新数组的成员new Array(1, 2) // [1, 2]new Array('a', 'b', 'c') // ['a', 'b', 'c'] 可以看到，Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。 静态方法Array.isArray()1234var arr = [1, 2, 3];typeof arr // "object"// 它可以弥补typeof运算符的不足。Array.isArray(arr) // true 实例方法valueOf()valueOf方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。 toString()toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。 push()push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 pop()pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组；对空数组使用pop方法，不会报错，而是返回undefined.1[].pop() // undefined push和pop结合使用，就构成了“后进先出”的栈结构（stack）。 shift()shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。 unshift()unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 join()join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔;如果数组成员是undefined或null或空位，会被转成空字符串。 concat()concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。 reverse()reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。 slice()slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。它的第一个参数为起始位置（从0开始）， 第二个参数为终止位置（但该位置的元素本身不包括在内）。 如果省略第二个参数，则一直返回到原数组的最后一个成员。没有参数，实际上等于返回一个原数组的拷贝。 如果slice方法的参数是负数，则表示倒数计算的位置。 如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。 splice()arr.splice(start, count, addElement1, addElement2, ...);splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。 splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 如果只是单纯地插入元素，splice方法的第二个参数可以设为0。 sort()sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。1234567891011121314151617[10111, 1101, 111].sort(function (a, b) &#123; return a - b;&#125;)// [111, 1101, 10111][ &#123; name: "张三", age: 30 &#125;, &#123; name: "李四", age: 24 &#125;, &#123; name: "王五", age: 28 &#125;].sort(function (o1, o2) &#123; return o1.age - o2.age;&#125;)// [// &#123; name: "李四", age: 24 &#125;,// &#123; name: "王五", age: 28 &#125;,// &#123; name: "张三", age: 30 &#125;// ] 上面代码中，sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。 map()map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。map方法的回调函数有三个参数，elem为当前成员的值，index为当前成员的位置，arr为原数组map方法还可以接受第二个参数，用来绑定回调函数内部的this变量 forEach()forEach方法不返回值，只用来循环操作数据。forEach方法也可以接受第二个参数，绑定参数函数的this变量forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。 filter()filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。filter方法还可以接受第二个参数，用来绑定参数函数内部的this变量。 some()接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。注意，对于空数组，some方法返回false，some方法是只要一个成员的返回值是true,则返回true every()用法同 some()every方法是所有成员的返回值都是true,则返回true注意，对于空数组，every方法返回true，回调函数都不会执行。 reduce()第一个参数都是一个函数。该函数接受以下四个参数。 累积变量，默认为数组的第一个成员 当前变量，默认为数组的第二个成员 当前位置（从0开始） 原数组 这四个参数之中，只有前两个是必须的，后两个则是可选的。123456789101112131415[1, 2, 3, 4, 5].reduce(function (a, b) &#123; console.log(a, b); return a + b;&#125;)// 1 2// 3 3// 6 4// 10 5//最后结果：15// 第二个参数 指定初始值[1, 2, 3, 4, 5].reduce(function (a, b) &#123; return a + b;&#125;, 10);// 25 reduceRight()reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。 indexOf()，lastIndexOf()indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1.indexOf方法还可以接受第二个参数，表示搜索的开始位置。lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1.注意，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。]]></content>
      <categories>
        <category>js原生</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[属性描述对象]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%B1%9E%E6%80%A7%E8%A1%A8%E8%BF%B0%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[概述JavaScript 提供了一个内部数据结构，用来表述对象的属性，控制它的行为。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。下面是属性描述对象的一个例子。123456789&#123; configurable:true, enumerable:true, value:1, writable:true, __proto__:Object, // 可称为隐式原型 一个对象实例通过内部属性[[Prototype]]跟踪其原型对象。 get:undefined, set:undefined&#125; 在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。即：对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。方法这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。具体如下图所示:上图表述： 构造函数Foo()构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。 原型对象Foo.prototypeFoo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。 实例f1和f2是Foo这个对象的两个实例，这两个对象也有属性proto，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。 Foo()除了是方法，也是对象啊，它也有proto属性，指向谁呢？指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的proto指向了Function.prototype。其实除了Foo()，Function(), Object()也是一样的道理。 原型对象也是对象啊，它的proto属性，又指向谁呢？同理，指向它的构造函数的原型对象呗。这里是Object.prototype. 最后，Object.prototype的proto属性指向null。 属性描述对象6个元属性 value： 该属性的属性值 writable：表示属性值（value）是否可改变（即是否可写），默认为true。 enumerable：布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。 configurable：布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。 get：函数，表示该属性的取值函数（getter），默认为undefined set：函数，表示该属性的存值函数（setter），默认为undefined。 描述符可同时具有的键值 configurable enumerable value writable get set 数据描述符 yes yes yes yes no no 存取描述符 yes yes no no yes yes Object.getOwnPropertyDescriptor()Object.getOwnPropertyDescriptor方法可以获取属性描述对象。它的第一个参数是一个对象，第二个参数是一个字符串，对应该对象的某个属性名。注意，Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性。12345678var obj = &#123; p: 'a' &#125;;Object.getOwnPropertyDescriptor(obj, 'p')// Object &#123; value: "a",// writable: true,// enumerable: true,// configurable: true// &#125; Object.getOwnPropertyNames()Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。 Object.defineProperty()，Object.defineProperties()Object.defineProperty(object, propertyName, attributesObject) object：属性所在的对象 propertyName：属性名（它应该是一个字符串） attributesObject：属性描述对象 1234567891011var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 123, writable: false, enumerable: true, configurable: false&#125;);obj.p // 123obj.p = 246;obj.p // 123 如果一次性定义或修改多个属性，可以使用Object.defineProperties方法。123456789101112var obj = Object.defineProperties(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true &#125;, p2: &#123; value: 'abc', enumerable: true &#125;, p3: &#123; get: function () &#123; return this.p1 + this.p2 &#125;, enumerable:true, configurable:true &#125;&#125;);obj.p1 // 123obj.p2 // "abc"obj.p3 // "123abc" Object.prototype.propertyIsEnumerable()实例对象的propertyIsEnumerable方法返回一个布尔值，用来判断某个属性是否可遍历。12345var obj = &#123;&#125;;obj.p = 123;obj.propertyIsEnumerable('p') // trueobj.propertyIsEnumerable('toString') // false 原属性valuevalue 目标属性的值12345678var obj = &#123;&#125;;obj.p = 123;Object.getOwnPropertyDescriptor(obj, 'p').value// 123Object.defineProperty(obj, 'p', &#123; value: 246 &#125;);obj.p // 246 writablewritable属性是一个布尔值，决定了目标属性的值（value）是否可以被改变。注意：严格模式下，writable为false的属性赋值会报错。12345678910var obj = &#123;&#125;;Object.defineProperty(obj, 'a', &#123; value: 37, writable: false&#125;);obj.a // 37obj.a = 25;obj.a // 37 如果原型对象的某个属性的writable为false，那么子对象将无法自定义这个属性。123456789var proto = Object.defineProperty(&#123;&#125;, 'foo', &#123; value: 'a', writable: false&#125;);var obj = Object.create(proto);obj.foo = 'b';obj.foo // 'a' 上面代码中，proto是原型对象，它的foo属性不可写。obj对象继承proto，也不可以再自定义这个属性了。如果是严格模式，这样做还会抛出一个错误。 但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。1234567891011var proto = Object.defineProperty(&#123;&#125;, 'foo', &#123; value: 'a', writable: false&#125;);var obj = Object.create(proto);Object.defineProperty(obj, 'foo', &#123; value: 'b'&#125;);obj.foo // "b" enumerableenumerable（可遍历性）返回一个布尔值，表示目标属性是否可遍历。具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。 for..in循环 Object.keys方法 JSON.stringify方法 因此，enumerable可以用来设置“秘密”属性。1234567891011121314var obj = &#123;&#125;;Object.defineProperty(obj, 'x', &#123; value: 123, enumerable: false&#125;);obj.x // 123for (var key in obj) &#123; console.log(key);&#125;// undefinedObject.keys(obj) // []JSON.stringify(obj) // "&#123;&#125;" configurableconfigurable(可配置性）返回一个布尔值，决定了是否可以修改属性描述对象。12345678910111213141516171819var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 1, writable: false, enumerable: false, configurable: false&#125;);Object.defineProperty(obj, 'p', &#123;value: 2&#125;)// TypeError: Cannot redefine property: p// 只要`writable`和`configurable`有一个为true，就允许改动value。Object.defineProperty(obj, 'p', &#123;writable: true&#125;)// TypeError: Cannot redefine property: pObject.defineProperty(obj, 'p', &#123;enumerable: true&#125;)// TypeError: Cannot redefine property: pObject.defineProperty(obj, 'p', &#123;configurable: true&#125;)// TypeError: Cannot redefine property: p 注意，writable只有在false改为true会报错，true改为false是允许的。至于value，只要writable和configurable有一个为true，就允许改动。另外，configurable为false时，直接目标属性赋值，不报错，但不会成功。 setter，getter取值函数get不能接受参数，存值函数set只能接受一个参数（即属性的值。存取器往往用于，属性的值依赖对象内部数据的场合。1234567891011121314151617181920212223242526272829303132333435var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; get: function () &#123; return 'getter'; &#125;, set: function (value) &#123; console.log('setter: ' + value); &#125;&#125;);obj.p // "getter"obj.p = 123 // "setter: 123"// es6 写法var obj = &#123; get p() &#123; return 'getter'; &#125;, set p(value) &#123; console.log('setter: ' + value); &#125;&#125;;var obj =&#123; $n : 5, get next() &#123; return this.$n++ &#125;, set next(n) &#123; if (n &gt;= this.$n) this.$n = n; else throw new Error('新的值必须大于当前值'); &#125;&#125;;obj.next // 5obj.next = 10;obj.next // 10obj.next = 5;// Uncaught Error: 新的值必须大于当前值// next属性的存值函数和取值函数，都依赖于内部属性$n 对象的拷贝有时，我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现。1234567var extend = function (to, from) &#123; for (var property in from) &#123; to[property] = from[property]; &#125; return to;&#125; 上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值。1234extend(&#123;&#125;, &#123; get a() &#123; return 1 &#125;&#125;)// &#123;a: 1&#125; 为了解决这个问题，我们可以通过Object.defineProperty方法来拷贝属性。12345678910111213var extend = function (to, from) &#123; for (var property in from) &#123; //过滤掉继承的属性 if (!from.hasOwnProperty(property)) continue; Object.defineProperty( to, property, Object.getOwnPropertyDescriptor(from, property) ); &#125; return to;&#125;extend(&#123;&#125;, &#123; get a()&#123; return 1 &#125; &#125;) 控制对象状态有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。 Object.preventExtensions()Object.preventExtensions方法可以使得一个对象无法再添加新的属性。 Object.isExtensible()Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。也就是说，检查是否可以为一个对象添加属性。 Object.seal()Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。Object.seal实质是把属性描述对象的configurable属性设为false，因此属性描述对象不再能改变了。Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值(writable还为true)。 Object.isSealed()Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。这时，Object.isExtensible方法也返回false。 Object.freeze()Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。 Object.isFrozen()使用Object.freeze方法以后，Object.isSealed将会返回true，Object.isExtensible返回false。 局限性上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。1234567var obj = new Object();Object.preventExtensions(obj);var proto = Object.getPrototypeOf(obj);proto.t = 'hello';obj.t// hello 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。12345678var obj = &#123; foo: 1, bar: ['a', 'b']&#125;;Object.freeze(obj);obj.bar.push('c');obj.bar // ["a", "b", "c"]]]></content>
      <categories>
        <category>js原生</category>
        <category>Object</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>属性表述对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object]]></title>
    <url>%2F2018%2F07%2F16%2FObject%2F</url>
    <content type="text"><![CDATA[概述JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。 Object 对象本身的方法所谓”本身的方法“就是直接定义在Object对象的方法。1Object.print = function (o) &#123; console.log(o) &#125;; Object的实例方法所谓实例方法就是定义在Object原型对象Object.prototype上的方法。它可以被Object实例直接使用。123456Object.prototype.print = function () &#123; console.log(this);&#125;;var obj = new Object();obj.print() // Object Object 构造函数Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。 Object 用作工具函数1234567891011121314151617181920212223242526272829303132var obj = Object();// 等同于var obj = Object(undefined);var obj = Object(null);obj instanceof Object // true// 参数为原始诗句类型var obj = Object(1);obj instanceof Object // trueobj instanceof Number // truevar obj = Object('foo');obj instanceof Object // trueobj instanceof String // truevar obj = Object(true);obj instanceof Object // trueobj instanceof Boolean // true// 参数为复杂数据类型var arr = [];var obj = Object(arr); // 返回原数组obj === arr // truevar value = &#123;&#125;;var obj = Object(value) // 返回原对象obj === value // truevar fn = function () &#123;&#125;;var obj = Object(fn); // 返回原函数obj === fn // true 利用工具函数 判断变量是否为对象的函数。123456function isObject(value) &#123; return value === Object(value);&#125;isObject([]) // trueisObject(true) // false Object构造函数的用法Object构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象.123456var o1 = &#123;a: 1&#125;;var o2 = new Object(o1);o1 === o2 // truevar obj = new Object(123);obj instanceof Number // true Object 的静态方法所谓“静态方法”，是指部署在Object对象自身的方法。 Object.keys（）Object.keys方法的参数是一个对象，返回一个数组。其元素来自于从给定的object上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。123456var obj = &#123; p1: 123, p2: 456&#125;;Object.keys(obj) // ["p1", "p2"] Object.getOwnPropertyNames与Object.keys类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。 其他方法对象属性模型的相关方法 Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。 Object.defineProperty()：通过描述对象，定义某个属性。 Object.defineProperties()：通过描述对象，定义多个属性。控制对象状态的方法 Object.preventExtensions()：防止对象扩展。 Object.isExtensible()：判断对象是否可扩展。 Object.seal()：禁止对象配置。 Object.isSealed()：判断一个对象是否可配置。 Object.freeze()：冻结一个对象。 Object.isFrozen()：判断一个对象是否被冻结。原型链相关方法 Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。 Object.getPrototypeOf()：获取对象的Prototype对象。 Object 的实例方法除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。 Object.prototype.valueOf()：返回当前对象对应的值。 Object.prototype.toString()：返回当前对象对应的字符串形式。 Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。 Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性 Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。 Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。 Object.prototype.valueOf()valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。valueOf方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法。123456789101112var obj = new Object();obj.valueOf() === obj // truevar obj = new Object();1 + obj // "1[object Object]"// 如果自定义valueOf方法，就可以得到想要的结果。var obj = new Object();obj.valueOf = function () &#123; return 2;&#125;;1 + obj // 3 Object.prototype.toString()toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。对于一个对象调用toString方法，会返回字符串[object Object];字符串[object Object]本身没有太大的用处，但是通过自定义toString方法，可以让对象在自动类型转换时，得到想要的字符串形式。数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。1234567891011121314151617181920212223242526var o1 = new Object();o1.toString() // "[object Object]"var o2 = &#123;a:1&#125;;o2.toString() // "[object Object]"var obj = new Object();obj.toString = function () &#123; return 'hello';&#125;;obj + ' ' + 'world' // "hello world"// 其他数据类型的 toString方法。[1, 2, 3].toString() // "1,2,3"'123'.toString() // "123"(function () &#123; return 123;&#125;).toString()// "function () &#123;// return 123;// &#125;"(new Date()).toString()// "Tue May 10 2016 09:11:31 GMT+0800 (CST)" toString() 的应用：判断数据类型Object.prototype.toString方法返回对象的类型字符串，因此可以用来判断一个值的类型。由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法。1234567891011121314151617181920212223var type = function (o)&#123; var s = Object.prototype.toString.call(o); return s.match(/\[object (.*?)\]/)[1].toLowerCase();&#125;;['Null','Undefined','Object','Array','String','Number','Boolean','Function','RegExp'].forEach(function (t) &#123; type['is' + t] = function (o) &#123; return type(o) === t.toLowerCase(); &#125;;&#125;);type.isObject(&#123;&#125;) // truetype.isNumber(NaN) // truetype.isRegExp(/abc/) // true Object.prototype.toLocaleString()这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的toLocaleString，用来返回针对某些地域的特定的值。1234567var obj = &#123;&#125;;obj.toString(obj) // "[object Object]"obj.toLocaleString(obj) // "[object Object]"var date = new Date();date.toString() // "Tue Jan 01 2018 12:01:33 GMT+0800 (CST)"date.toLocaleString() // "1/01/2018, 12:01:33 PM" Object.prototype.hasOwnProperty()Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。12345var obj = &#123; p: 123&#125;;obj.hasOwnProperty('p') // trueobj.hasOwnProperty('toString') // false]]></content>
      <categories>
        <category>js原生</category>
        <category>Object</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误处理机制]]></title>
    <url>%2F2018%2F07%2F15%2F%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Error 实例对象JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。12var err = new Error('出错了');err.message // "出错了" error 实例的属性和方法 message：错误提示信息 错误名称（非标准属性 stack：错误的堆栈（非标准属性） 1234567891011121314151617function throwit() &#123; throw new Error('');&#125;function catchit() &#123; try &#123; throwit(); &#125; catch(e) &#123; console.log(e.stack); // print stack trace &#125;&#125;// 错误堆栈的最内层是throwit函数，然后是catchit函数，最后是函数的运行环境。catchit()// Error// at throwit (~/examples/throwcatch.js:9:11)// at catchit (~/examples/throwcatch.js:3:9)// at repl:1:5 原生错误类型 Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。 SyntaxError 对象SyntaxError对象是解析代码时发生的语法错误。1234567// 变量名错误var 1a;// Uncaught SyntaxError: Invalid or unexpected token// 缺少括号console.log 'hello');// Uncaught SyntaxError: Unexpected string ReferenceError 对象referenceError对象是引用一个不存在的变量时发生的错误。123// 使用一个不存在的变量unknownVariable// Uncaught ReferenceError: unknownVariable is not defined RangeError 对象RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。123// 数组长度不得为负数new Array(-1)// Uncaught RangeError: Invalid array length TypeError 对象TypeError对象是变量或参数不是预期类型时发生的错误。123var obj = &#123;&#125;;obj.unknownMethod()// Uncaught TypeError: obj.unknownMethod is not a function URIError 对象URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。12decodeURI('%2')// URIError: URI malformed EvalError 对象eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。 自定义错误类型除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。1234567function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError; throw语句throw语句的作用是手动中断程序执行，抛出一个错误。1234if (x &lt; 0) &#123; throw new Error('x 必须为正数');&#125;// Uncaught ReferenceError: x is not defined throw 可抛出任意类型的值1234567891011121314151617181920212223// 抛出一个字符串throw 'Error！'; // Uncaught Error！// 抛出一个数值throw 42; // Uncaught 42// 抛出一个布尔值throw true; // Uncaught true// 抛出一个对象throw &#123; toString: function () &#123; return 'Error!'; &#125;&#125;; // // Uncaught &#123;toString: ƒ&#125;// 抛出一个自定义错误function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;throw new UserError('出错了！'); // Uncaught UserError &#123;message: "出错了！", name: "UserError"&#125; try…catch 结构一旦发生错误，程序就中止执行了。JavaScript 提供了try...catch结构，允许对错误进行处理，选择是否往下执行。123456789try &#123; throw new Error('出错了!');&#125; catch (e) &#123; console.log(e.name + ": " + e.message); console.log(e.stack);&#125;// Error: 出错了!// at &lt;anonymous&gt;:3:9// ... catch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。123456789try &#123; throw "出错了";&#125; catch (e) &#123; console.log(111);&#125; // 被catch代码块捕获后，程序会继续向下执行console.log(222); // 111// 222 catch代码块之中，还可以再抛出错误，甚至使用嵌套的try…catch结构1234567891011var n = 100;try &#123; throw n;&#125; catch (e) &#123; if (e &lt;= 50) &#123; // ... &#125; else &#123; throw e; &#125;&#125; finallytry…catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。123456789101112131415161718192021222324252627282930313233343536373839404142434445 function f() &#123; try &#123; console.log(0); throw 'bug'; &#125; catch(e) &#123; console.log(1); return true; // 这句原本会延迟到 finally 代码块结束再执行 console.log(2); // 不会运行 &#125; finally &#123; console.log(3); return false; // 这句会覆盖掉前面那句 return console.log(4); // 不会运行 &#125; console.log(5); // 不会运行 &#125; var result = f(); // 0 // 1 // 3 result // falsefunction f() &#123; try &#123; throw '出错了！'; &#125; catch(e) &#123; console.log('捕捉到内部错误'); throw e; // 这句原本会等到finally结束再执行 &#125; finally &#123; return false; // 直接返回 &#125;&#125;try &#123; f();&#125; catch(e) &#123; // 此处不会执行 console.log('caught outer "bogus"');&#125;// 捕捉到内部错误]]></content>
      <categories>
        <category>js原生</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[function]]></title>
    <url>%2F2018%2F07%2F15%2Ffunction%2F</url>
    <content type="text"><![CDATA[函数的声明函数 有三种申明方式： function 命令 函数表达式 Function 构造函数 function 命令123function print(s) &#123; console.log(s);&#125; 函数表达式采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体 外部无效。12345678var print = function(s) &#123; console.log(s);&#125;;var print = function x()&#123; // x 只能在此函数内部使用 console.log(typeof x);&#125;; Function最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。12345678910var add = new Function( 'x', 'y', 'return x + y');// 等同于function add(x, y) &#123; return x + y;&#125; 函数的属性和方法name属性返回函数的名字12345678910function f1() &#123;&#125;f1.name // "f1"var f2 = function () &#123;&#125;;f2.name // "f2"var f3 = function myName() &#123;&#125;;// 返回 function命令后 函数名f3.name // 'myName' length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。123// 不管调用时输入了多少个参数，length属性始终等于2。function f(a, b) &#123;&#125;f.length // 2 函数的参数参数的传递方式 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部；如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference） arguments 对象arguments读取函数调用时传入函数内部所有的参数，arguments为只读对象(伪数组)1234var args = Array.prototype.slice.call(arguments);// ES6var argus = Array.from(arguments) calleearguments对象带有一个callee属性，返回它所对应的原函数;可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。 函数的其他特性闭包闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它的诞生环境一直存在。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。123456789101112function createIncrementor(start) &#123; // 为了在函数外部读取 start的值 将 start的 值返回 return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);// inc使得函数createIncrementor的内部环境，一直存在于内存中。所以，闭包可以看作是函数内部作用域的一个接口。inc() // 5inc() // 6inc() // 7]]></content>
      <categories>
        <category>js原生</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>function</tag>
      </tags>
  </entry>
</search>
