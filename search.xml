<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[属性描述对象]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%B1%9E%E6%80%A7%E8%A1%A8%E8%BF%B0%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[概述JavaScript 提供了一个内部数据结构，用来表述对象的属性，控制它的行为。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。下面是属性描述对象的一个例子。123456789&#123; configurable:true, enumerable:true, value:1, writable:true, __proto__:Object, // 可称为隐式原型 一个对象实例通过内部属性[[Prototype]]跟踪其原型对象。 get:undefined, set:undefined&#125; 在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。即：对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。方法这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。具体如下图所示:上图表述： 构造函数Foo()构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。 原型对象Foo.prototypeFoo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。 实例f1和f2是Foo这个对象的两个实例，这两个对象也有属性proto，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。 Foo()除了是方法，也是对象啊，它也有proto属性，指向谁呢？指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的proto指向了Function.prototype。其实除了Foo()，Function(), Object()也是一样的道理。 原型对象也是对象啊，它的proto属性，又指向谁呢？同理，指向它的构造函数的原型对象呗。这里是Object.prototype. 最后，Object.prototype的proto属性指向null。 属性描述对象6个元属性 value： 该属性的属性值 writable：表示属性值（value）是否可改变（即是否可写），默认为true。 enumerable：布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。 configurable：布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。 get：函数，表示该属性的取值函数（getter），默认为undefined set：函数，表示该属性的存值函数（setter），默认为undefined。 描述符可同时具有的键值 configurable enumerable value writable get set 数据描述符 yes yes yes yes no no 存取描述符 yes yes no no yes yes Object.getOwnPropertyDescriptor()Object.getOwnPropertyDescriptor方法可以获取属性描述对象。它的第一个参数是一个对象，第二个参数是一个字符串，对应该对象的某个属性名。注意，Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性。12345678var obj = &#123; p: 'a' &#125;;Object.getOwnPropertyDescriptor(obj, 'p')// Object &#123; value: "a",// writable: true,// enumerable: true,// configurable: true// &#125; Object.getOwnPropertyNames()Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。 Object.defineProperty()，Object.defineProperties()Object.defineProperty(object, propertyName, attributesObject) object：属性所在的对象 propertyName：属性名（它应该是一个字符串） attributesObject：属性描述对象1234567891011var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 123, writable: false, enumerable: true, configurable: false&#125;);obj.p // 123obj.p = 246;obj.p // 123 如果一次性定义或修改多个属性，可以使用Object.defineProperties方法。123456789101112var obj = Object.defineProperties(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true &#125;, p2: &#123; value: 'abc', enumerable: true &#125;, p3: &#123; get: function () &#123; return this.p1 + this.p2 &#125;, enumerable:true, configurable:true &#125;&#125;);obj.p1 // 123obj.p2 // "abc"obj.p3 // "123abc"]]></content>
      <categories>
        <category>js原生</category>
        <category>Object</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>属性表述对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object]]></title>
    <url>%2F2018%2F07%2F16%2FObject%2F</url>
    <content type="text"><![CDATA[概述JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。 Object 对象本身的方法所谓”本身的方法“就是直接定义在Object对象的方法。1Object.print = function (o) &#123; console.log(o) &#125;; Object的实例方法所谓实例方法就是定义在Object原型对象Object.prototype上的方法。它可以被Object实例直接使用。123456Object.prototype.print = function () &#123; console.log(this);&#125;;var obj = new Object();obj.print() // Object Object 构造函数Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。 Object 用作工具函数1234567891011121314151617181920212223242526272829303132var obj = Object();// 等同于var obj = Object(undefined);var obj = Object(null);obj instanceof Object // true// 参数为原始诗句类型var obj = Object(1);obj instanceof Object // trueobj instanceof Number // truevar obj = Object('foo');obj instanceof Object // trueobj instanceof String // truevar obj = Object(true);obj instanceof Object // trueobj instanceof Boolean // true// 参数为复杂数据类型var arr = [];var obj = Object(arr); // 返回原数组obj === arr // truevar value = &#123;&#125;;var obj = Object(value) // 返回原对象obj === value // truevar fn = function () &#123;&#125;;var obj = Object(fn); // 返回原函数obj === fn // true 利用工具函数 判断变量是否为对象的函数。123456function isObject(value) &#123; return value === Object(value);&#125;isObject([]) // trueisObject(true) // false Object构造函数的用法Object构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象.123456var o1 = &#123;a: 1&#125;;var o2 = new Object(o1);o1 === o2 // truevar obj = new Object(123);obj instanceof Number // true Object 的静态方法所谓“静态方法”，是指部署在Object对象自身的方法。 Object.keys（）Object.keys方法的参数是一个对象，返回一个数组。其元素来自于从给定的object上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。123456var obj = &#123; p1: 123, p2: 456&#125;;Object.keys(obj) // ["p1", "p2"] Object.getOwnPropertyNames与Object.keys类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。 其他方法对象属性模型的相关方法 Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。 Object.defineProperty()：通过描述对象，定义某个属性。 Object.defineProperties()：通过描述对象，定义多个属性。控制对象状态的方法 Object.preventExtensions()：防止对象扩展。 Object.isExtensible()：判断对象是否可扩展。 Object.seal()：禁止对象配置。 Object.isSealed()：判断一个对象是否可配置。 Object.freeze()：冻结一个对象。 Object.isFrozen()：判断一个对象是否被冻结。原型链相关方法 Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。 Object.getPrototypeOf()：获取对象的Prototype对象。 Object 的实例方法除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。 Object.prototype.valueOf()：返回当前对象对应的值。 Object.prototype.toString()：返回当前对象对应的字符串形式。 Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。 Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性 Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。 Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。 Object.prototype.valueOf()valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。valueOf方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法。123456789101112var obj = new Object();obj.valueOf() === obj // truevar obj = new Object();1 + obj // "1[object Object]"// 如果自定义valueOf方法，就可以得到想要的结果。var obj = new Object();obj.valueOf = function () &#123; return 2;&#125;;1 + obj // 3 Object.prototype.toString()toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。对于一个对象调用toString方法，会返回字符串[object Object];字符串[object Object]本身没有太大的用处，但是通过自定义toString方法，可以让对象在自动类型转换时，得到想要的字符串形式。数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。1234567891011121314151617181920212223242526var o1 = new Object();o1.toString() // "[object Object]"var o2 = &#123;a:1&#125;;o2.toString() // "[object Object]"var obj = new Object();obj.toString = function () &#123; return 'hello';&#125;;obj + ' ' + 'world' // "hello world"// 其他数据类型的 toString方法。[1, 2, 3].toString() // "1,2,3"'123'.toString() // "123"(function () &#123; return 123;&#125;).toString()// "function () &#123;// return 123;// &#125;"(new Date()).toString()// "Tue May 10 2016 09:11:31 GMT+0800 (CST)" toString() 的应用：判断数据类型Object.prototype.toString方法返回对象的类型字符串，因此可以用来判断一个值的类型。由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法。1234567891011121314151617181920212223var type = function (o)&#123; var s = Object.prototype.toString.call(o); return s.match(/\[object (.*?)\]/)[1].toLowerCase();&#125;;['Null','Undefined','Object','Array','String','Number','Boolean','Function','RegExp'].forEach(function (t) &#123; type['is' + t] = function (o) &#123; return type(o) === t.toLowerCase(); &#125;;&#125;);type.isObject(&#123;&#125;) // truetype.isNumber(NaN) // truetype.isRegExp(/abc/) // true Object.prototype.toLocaleString()这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的toLocaleString，用来返回针对某些地域的特定的值。1234567var obj = &#123;&#125;;obj.toString(obj) // "[object Object]"obj.toLocaleString(obj) // "[object Object]"var date = new Date();date.toString() // "Tue Jan 01 2018 12:01:33 GMT+0800 (CST)"date.toLocaleString() // "1/01/2018, 12:01:33 PM" Object.prototype.hasOwnProperty()Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。12345var obj = &#123; p: 123&#125;;obj.hasOwnProperty('p') // trueobj.hasOwnProperty('toString') // false]]></content>
      <categories>
        <category>js原生</category>
        <category>Object</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误处理机制]]></title>
    <url>%2F2018%2F07%2F15%2F%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Error 实例对象JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。12var err = new Error('出错了');err.message // "出错了" error 实例的属性和方法 message：错误提示信息 错误名称（非标准属性 stack：错误的堆栈（非标准属性） 1234567891011121314151617function throwit() &#123; throw new Error('');&#125;function catchit() &#123; try &#123; throwit(); &#125; catch(e) &#123; console.log(e.stack); // print stack trace &#125;&#125;// 错误堆栈的最内层是throwit函数，然后是catchit函数，最后是函数的运行环境。catchit()// Error// at throwit (~/examples/throwcatch.js:9:11)// at catchit (~/examples/throwcatch.js:3:9)// at repl:1:5 原生错误类型 Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。 SyntaxError 对象SyntaxError对象是解析代码时发生的语法错误。1234567// 变量名错误var 1a;// Uncaught SyntaxError: Invalid or unexpected token// 缺少括号console.log 'hello');// Uncaught SyntaxError: Unexpected string ReferenceError 对象referenceError对象是引用一个不存在的变量时发生的错误。123// 使用一个不存在的变量unknownVariable// Uncaught ReferenceError: unknownVariable is not defined RangeError 对象RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。123// 数组长度不得为负数new Array(-1)// Uncaught RangeError: Invalid array length TypeError 对象TypeError对象是变量或参数不是预期类型时发生的错误。123var obj = &#123;&#125;;obj.unknownMethod()// Uncaught TypeError: obj.unknownMethod is not a function URIError 对象URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。12decodeURI('%2')// URIError: URI malformed EvalError 对象eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。 自定义错误类型除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。1234567function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError; throw语句throw语句的作用是手动中断程序执行，抛出一个错误。1234if (x &lt; 0) &#123; throw new Error('x 必须为正数');&#125;// Uncaught ReferenceError: x is not defined throw 可抛出任意类型的值1234567891011121314151617181920212223// 抛出一个字符串throw 'Error！'; // Uncaught Error！// 抛出一个数值throw 42; // Uncaught 42// 抛出一个布尔值throw true; // Uncaught true// 抛出一个对象throw &#123; toString: function () &#123; return 'Error!'; &#125;&#125;; // // Uncaught &#123;toString: ƒ&#125;// 抛出一个自定义错误function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;throw new UserError('出错了！'); // Uncaught UserError &#123;message: "出错了！", name: "UserError"&#125; try…catch 结构一旦发生错误，程序就中止执行了。JavaScript 提供了try...catch结构，允许对错误进行处理，选择是否往下执行。123456789try &#123; throw new Error('出错了!');&#125; catch (e) &#123; console.log(e.name + ": " + e.message); console.log(e.stack);&#125;// Error: 出错了!// at &lt;anonymous&gt;:3:9// ... catch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。123456789try &#123; throw "出错了";&#125; catch (e) &#123; console.log(111);&#125; // 被catch代码块捕获后，程序会继续向下执行console.log(222); // 111// 222 catch代码块之中，还可以再抛出错误，甚至使用嵌套的try…catch结构1234567891011var n = 100;try &#123; throw n;&#125; catch (e) &#123; if (e &lt;= 50) &#123; // ... &#125; else &#123; throw e; &#125;&#125; finallytry…catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。123456789101112131415161718192021222324252627282930313233343536373839404142434445 function f() &#123; try &#123; console.log(0); throw 'bug'; &#125; catch(e) &#123; console.log(1); return true; // 这句原本会延迟到 finally 代码块结束再执行 console.log(2); // 不会运行 &#125; finally &#123; console.log(3); return false; // 这句会覆盖掉前面那句 return console.log(4); // 不会运行 &#125; console.log(5); // 不会运行 &#125; var result = f(); // 0 // 1 // 3 result // falsefunction f() &#123; try &#123; throw '出错了！'; &#125; catch(e) &#123; console.log('捕捉到内部错误'); throw e; // 这句原本会等到finally结束再执行 &#125; finally &#123; return false; // 直接返回 &#125;&#125;try &#123; f();&#125; catch(e) &#123; // 此处不会执行 console.log('caught outer "bogus"');&#125;// 捕捉到内部错误]]></content>
      <categories>
        <category>js原生</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[function]]></title>
    <url>%2F2018%2F07%2F15%2Ffunction%2F</url>
    <content type="text"><![CDATA[函数的声明函数 有三种申明方式： function 命令 函数表达式 Function 构造函数 function 命令123function print(s) &#123; console.log(s);&#125; 函数表达式采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体 外部无效。12345678var print = function(s) &#123; console.log(s);&#125;;var print = function x()&#123; // x 只能在此函数内部使用 console.log(typeof x);&#125;; Function最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。12345678910var add = new Function( 'x', 'y', 'return x + y');// 等同于function add(x, y) &#123; return x + y;&#125; 函数的属性和方法name属性返回函数的名字12345678910function f1() &#123;&#125;f1.name // "f1"var f2 = function () &#123;&#125;;f2.name // "f2"var f3 = function myName() &#123;&#125;;// 返回 function命令后 函数名f3.name // 'myName' length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。123// 不管调用时输入了多少个参数，length属性始终等于2。function f(a, b) &#123;&#125;f.length // 2 函数的参数参数的传递方式 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部；如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference） arguments 对象arguments读取函数调用时传入函数内部所有的参数，arguments为只读对象(伪数组)1234var args = Array.prototype.slice.call(arguments);// ES6var argus = Array.from(arguments) calleearguments对象带有一个callee属性，返回它所对应的原函数;可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。 函数的其他特性闭包闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它的诞生环境一直存在。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。123456789101112function createIncrementor(start) &#123; // 为了在函数外部读取 start的值 将 start的 值返回 return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);// inc使得函数createIncrementor的内部环境，一直存在于内存中。所以，闭包可以看作是函数内部作用域的一个接口。inc() // 5inc() // 6inc() // 7]]></content>
      <categories>
        <category>js原生</category>
      </categories>
      <tags>
        <tag>js原生</tag>
        <tag>function</tag>
      </tags>
  </entry>
</search>
